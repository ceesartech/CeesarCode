{
  "id": "canva-machine learning engineer-senior-design-embedding-pipeline",
  "title": "Design an Embedding Pipeline for Canva Templates",
  "statement": "Canva has millions of templates. We want to build a system to recommend similar templates to a user based on their current selection. Design an end-to-end embedding pipeline that ingests Canva templates (represented as JSON blobs containing information about layers, colors, fonts, etc.), generates vector embeddings, and enables efficient similarity search.  \n\nConsider the following:\n\n*   **Template Representation:** How will you represent templates in a way suitable for embedding? What features are most important to capture visual similarity?\n*   **Embedding Model:** What kind of model would you use for generating embeddings (e.g., a deep learning model trained from scratch, fine-tuning a pre-trained model, using an API like CLIP)?  Justify your choice.\n*   **Data Preprocessing:** How will you preprocess the template data before feeding it into the embedding model?\n*   **Scalability:** How will you handle millions of templates and billions of similarity searches per day?\n*   **Embedding Storage and Retrieval:** What data structure and/or database would you use to store and retrieve the embeddings efficiently (e.g., FAISS, Annoy, specialized vector database)?\n*   **Evaluation:** How would you evaluate the quality of the embeddings and the recommendations generated by the system? Provide metrics and experiment design ideas.\n\nAssume you have access to a Spark cluster for distributed processing. Provide a high-level architecture diagram and describe the key components and their interactions.\n\n**Example:**\n\nInput: A JSON blob representing a Canva template (details omitted for brevity).\nOutput: A vector embedding representing the template.\n",
  "languages": [
    "python",
    "java",
    "cpp"
  ],
  "stub": {
    "cpp": "class Solution {\npublic:\n    void designEmbeddingPipeline() {\n        // Your code here: Provide a high-level design document in comments.\n        // Consider outlining:\n        // 1. Template Representation\n        // 2. Embedding Model Selection\n        // 3. Data Preprocessing Steps\n        // 4. Scalability Strategy (e.g., using Spark)\n        // 5. Embedding Storage and Retrieval (e.g., FAISS, vector database)\n        // 6. Evaluation Metrics and Experiment Design\n    }\n};",
    "java": "class Solution {\n    public void designEmbeddingPipeline() {\n        // Your code here: Provide a high-level design document in comments.\n        // Consider outlining:\n        // 1. Template Representation\n        // 2. Embedding Model Selection\n        // 3. Data Preprocessing Steps\n        // 4. Scalability Strategy (e.g., using Spark)\n        // 5. Embedding Storage and Retrieval (e.g., FAISS, vector database)\n        // 6. Evaluation Metrics and Experiment Design\n    }\n}",
    "python": "def design_embedding_pipeline():\n    # Your code here: Provide a high-level design document in comments.\n    # Consider outlining:\n    # 1. Template Representation\n    # 2. Embedding Model Selection\n    # 3. Data Preprocessing Steps\n    # 4. Scalability Strategy (e.g., using Spark)\n    # 5. Embedding Storage and Retrieval (e.g., FAISS, vector database)\n    # 6. Evaluation Metrics and Experiment Design\n    pass"
  }
}