{
  "ID": "reddit-software engineer-senior-adaptive-content-feed-generation",
  "Title": "Adaptive Content Feed Generation",
  "Statement": "Reddit's core experience revolves around personalized feeds. This problem asks you to build and refine a system for generating a user's content feed.",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cvector\u003e\n#include \u003cstring\u003e\n#include \u003cunordered_map\u003e\n#include \u003cunordered_set\u003e\n#include \u003calgorithm\u003e\n\nstruct Post {\n    std::string id;\n    std::string subreddit;\n    int upvotes;\n    int downvotes;\n    long long timestamp;\n};\n\nclass Solution {\npublic:\n    std::vector\u003cstd::string\u003e getUserFeed(const std::string\u0026 userId, const std::unordered_map\u003cstd::string, std::unordered_set\u003cstd::string\u003e\u003e\u0026 subscriptions, const std::vector\u003cPost\u003e\u0026 posts, long long currentTimestamp) {\n        // Part 1: Basic Subreddit Feed\n        // Your code here\n        return {};\n    }\n};",
    "go": "package main\n\ntype Post struct {\n    ID string\n    Subreddit string\n    Upvotes int\n    Downvotes int\n    Timestamp int64\n}\n\nfunc GetUserFeed(userId string, subscriptions map[string][]string, posts []Post, currentTimestamp int64) []string {\n    // Part 1: Basic Subreddit Feed\n    // Your code here\n    return []string{}\n}",
    "java": "import java.util.*;\n\nclass Solution {\n    static class Post {\n        String id; String subreddit; int upvotes; int downvotes; long timestamp;\n        public Post(String id, String subreddit, int upvotes, int downvotes, long timestamp) {\n            this.id = id; this.subreddit = subreddit; this.upvotes = upvotes; this.downvotes = downvotes; this.timestamp = timestamp;\n        }\n    }\n    public List\u003cString\u003e getUserFeed(String userId, Map\u003cString, Set\u003cString\u003e\u003e subscriptions, List\u003cPost\u003e posts, long currentTimestamp) {\n        // Part 1: Basic Subreddit Feed\n        // Your code here\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "function getUserFeed(userId, subscriptions, posts, currentTimestamp) {\n    // Part 1: Basic Subreddit Feed\n    // Your code here\n    return [];\n}",
    "python": "def get_user_feed(user_id: str, subscriptions: dict, posts: list, current_timestamp: int) -\u003e list:\n    # Part 1: Basic Subreddit Feed\n    # Your code here\n    pass",
    "rust": "pub struct Post {\n    pub id: String,\n    pub subreddit: String,\n    pub upvotes: i32,\n    pub downvotes: i32,\n    pub timestamp: i64,\n}\n\npub fn get_user_feed(user_id: \u0026str, subscriptions: \u0026std::collections::HashMap\u003cString, std::collections::HashSet\u003cString\u003e\u003e, posts: \u0026[Post], current_timestamp: i64) -\u003e Vec\u003cString\u003e {\n    // Part 1: Basic Subreddit Feed\n    // Your code here\n    vec![]\n}"
  },
  "Type": "coding",
  "IsMultiPart": true,
  "Parts": [
    {
      "partNumber": 1,
      "statement": "Implement `get_user_feed(user_id, subscriptions, posts, current_timestamp)` to generate a personalized feed for a user. The feed should contain posts from subreddits the user `user_id` subscribes to. Sort these posts by a simple 'hotness' score: `(upvotes - downvotes)`, in descending order.\n\n**Input:**\n*   `user_id`: A string representing the target user.\n*   `subscriptions`: A dictionary/map where keys are user IDs and values are sets/lists of subreddit IDs they subscribe to.\n*   `posts`: A list of dictionaries/objects, each representing a post with fields: `id` (str), `subreddit` (str), `upvotes` (int), `downvotes` (int), `timestamp` (int, Unix timestamp).\n*   `current_timestamp`: An integer representing the current time (for later parts, but passed for consistency).\n\n**Output:** A list of `post_id` strings, sorted by score in descending order.\n\n**Example:**\n```\nsubscriptions = {\"user1\": {\"subredditA\", \"subredditB\"}}\nposts = [\n    {\"id\": \"p1\", \"subreddit\": \"subredditA\", \"upvotes\": 100, \"downvotes\": 10, \"timestamp\": 1678886400},\n    {\"id\": \"p2\", \"subreddit\": \"subredditB\", \"upvotes\": 50, \"downvotes\": 5, \"timestamp\": 1678886401},\n    {\"id\": \"p3\", \"subreddit\": \"subredditA\", \"upvotes\": 200, \"downvotes\": 100, \"timestamp\": 1678886402},\n    {\"id\": \"p4\", \"subreddit\": \"subredditC\", \"upvotes\": 1000, \"downvotes\": 50, \"timestamp\": 1678886403}\n]\n# For user1, subscribed to subredditA and subredditB.\n# p1 score: 90\n# p2 score: 45\n# p3 score: 100\nget_user_feed(\"user1\", subscriptions, posts, 1678886403) == [\"p3\", \"p1\", \"p2\"]\n```",
      "stub": null
    },
    {
      "partNumber": 2,
      "statement": "Enhance `get_user_feed` to incorporate time decay into the post's hotness score. The new score calculation should be: `score = (upvotes - downvotes) - ((current_timestamp - post.timestamp) / 3600.0)`. This subtracts 1 point per hour a post has been alive. Posts should still be sorted by this new score in descending order.\n\n**Example (building on Part 1's data, with new timestamps for demonstration):**\n```\nsubscriptions = {\"user1\": {\"subredditA\", \"subredditB\"}}\nposts = [\n    {\"id\": \"p1\", \"subreddit\": \"subredditA\", \"upvotes\": 100, \"downvotes\": 10, \"timestamp\": 1678886400}, # 10 hours old\n    {\"id\": \"p2\", \"subreddit\": \"subredditB\", \"upvotes\": 80, \"downvotes\": 5, \"timestamp\": 1678886400 + 3600 * 5}, # 5 hours old\n    {\"id\": \"p3\", \"subreddit\": \"subredditA\", \"upvotes\": 95, \"downvotes\": 0, \"timestamp\": 1678886400 + 3600 * 9}  # 1 hour old\n]\ncurrent_timestamp = 1678886400 + 3600 * 10 # 10 hours after p1's timestamp\n\n# p1 score: (100-10) - (36000 / 3600.0) = 90 - 10 = 80\n# p2 score: (80-5) - (18000 / 3600.0) = 75 - 5 = 70\n# p3 score: (95-0) - (3600 / 3600.0) = 95 - 1 = 94\nget_user_feed(\"user1\", subscriptions, posts, current_timestamp) == [\"p3\", \"p1\", \"p2\"]\n```",
      "stub": null
    },
    {
      "partNumber": 3,
      "statement": "Further refine the feed generation by incorporating personalized relevance and hidden posts. The `get_user_feed` function should now also accept:\n1.  `hidden_posts: Set[str]`: A set of `post_id`s that the user has explicitly hidden and should not appear in their feed.\n2.  `favorite_subreddits: Set[str]`: A set of `subreddit_id`s that the user particularly likes. Posts from these subreddits should receive a score bonus (e.g., `+10`).\n\n**Input:** Same as Part 2, plus `hidden_posts: Set[str]` and `favorite_subreddits: Set[str]`.\n\n**Output:** `List[str]` of `post_id`s, sorted by the new personalized score, excluding hidden posts.\n\n**Example (building on Part 2's data):**\n```\nhidden_posts = {\"p1\"}\nfavorite_subreddits = {\"subredditA\"}\n\n# p1 is hidden, so it's excluded.\n# p2 score: 70 (no change)\n# p3 score: 94 (base) + 10 (from favorite_subreddits) = 104\nget_user_feed(\"user1\", subscriptions, posts, current_timestamp, hidden_posts, favorite_subreddits) == [\"p3\", \"p2\"]\n```",
      "stub": null
    }
  ]
}