{
  "ID": "reddit-software engineer-senior-comment-tree-flattening-and-pagination",
  "Title": "Comment Tree Flattening and Pagination",
  "Statement": "Reddit comments are organized in a nested, tree-like structure. When displaying them, the frontend typically 'flattens' this structure into a linear list, using indentation to denote depth, and paginates the results. Implement functions to handle this.\n\nAssume a `Comment` object has `id`, `parent_id` (null for top-level comments), `text`, and `author`. For display purposes, you'll need to calculate its `depth` (0 for top-level, 1 for its children, etc.).\n\n**Part 1: Flatten Comment Tree**\nImplement a function `flatten_comments(comments_data)` that takes a list of `Comment` objects (not necessarily in order) and returns a flattened list of `Comment` objects, each enriched with a `depth` attribute. The comments should appear in a depth-first traversal order, with top-level comments first, followed by their direct children, then their grandchildren, and so on.\n\n**Example Input:**\n`comments_data = [`\n  `{'id': 'c1', 'parent_id': None, 'text': 'Top comment 1', 'author': 'u1'},`\n  `{'id': 'c3', 'parent_id': 'c2', 'text': 'Reply to c2', 'author': 'u3'},`\n  `{'id': 'c2', 'parent_id': 'c1', 'text': 'Reply to c1', 'author': 'u2'},`\n  `{'id': 'c4', 'parent_id': None, 'text': 'Top comment 2', 'author': 'u4'}`\n`]`\n\n**Example Output for Part 1 (with `depth` added):**\n`[`\n  `{'id': 'c1', 'parent_id': None, 'text': 'Top comment 1', 'author': 'u1', 'depth': 0},`\n  `{'id': 'c2', 'parent_id': 'c1', 'text': 'Reply to c1', 'author': 'u2', 'depth': 1},`\n  `{'id': 'c3', 'parent_id': 'c2', 'text': 'Reply to c2', 'author': 'u3', 'depth': 2},`\n  `{'id': 'c4', 'parent_id': None, 'text': 'Top comment 2', 'author': 'u4', 'depth': 0}`\n`]`",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cvector\u003e\n#include \u003cunordered_map\u003e\n#include \u003calgorithm\u003e\n\nstruct Comment {\n    std::string id;\n    std::string parent_id; // Use empty string for None/null\n    std::string text;\n    std::string author;\n    int depth;\n};\n\nclass Solution {\npublic:\n    std::vector\u003cComment\u003e flattenComments(const std::vector\u003cComment\u003e\u0026 comments_data) {\n        // Your code for Part 1\n        return {};\n    }\n};",
    "go": "package main\n\ntype Comment struct {\n    Id       string\n    ParentId string // Empty string for None/null\n    Text     string\n    Author   string\n    Depth    int // To be filled during flattening\n}\n\nfunc FlattenComments(commentsData []Comment) []Comment {\n    // Your code for Part 1\n    return []Comment{}\n}",
    "java": "import java.util.*;\n\nclass Comment {\n    String id;\n    String parentId;\n    String text;\n    String author;\n    int depth;\n\n    public Comment(String id, String parentId, String text, String author) {\n        this.id = id;\n        this.parentId = parentId;\n        this.text = text;\n        this.author = author;\n        this.depth = -1;\n    }\n}\n\nclass Solution {\n    public List\u003cComment\u003e flattenComments(List\u003cMap\u003cString, String\u003e\u003e commentsData) {\n        // Your code for Part 1\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "class Comment {\n    constructor(id, parent_id, text, author) {\n        this.id = id;\n        this.parent_id = parent_id;\n        this.text = text;\n        this.author = author;\n        this.depth = -1; // To be filled during flattening\n    }\n}\n\nfunction flattenComments(commentsData) {\n    // Your code for Part 1\n    return [];\n}",
    "python": "class Comment:\n    def __init__(self, id: str, parent_id: str, text: str, author: str):\n        self.id = id\n        self.parent_id = parent_id\n        self.text = text\n        self.author = author\n        self.depth = -1 # To be filled during flattening\n\ndef flatten_comments(comments_data: list[dict]) -\u003e list[Comment]:\n    # Your code for Part 1\n    pass",
    "rust": "use std::collections::HashMap;\n\npub struct Comment {\n    id: String,\n    parent_id: Option\u003cString\u003e, // Use Option\u003cString\u003e for nullable parent_id\n    text: String,\n    author: String,\n    depth: i32, // To be filled during flattening\n}\n\nimpl Comment {\n    pub fn new(id: String, parent_id: Option\u003cString\u003e, text: String, author: String) -\u003e Self {\n        Comment { id, parent_id, text, author, depth: -1 }\n    }\n}\n\npub fn flatten_comments(comments_data: Vec\u003cComment\u003e) -\u003e Vec\u003cComment\u003e {\n    // Your code for Part 1\n    vec![]\n}"
  },
  "Type": "coding"
}