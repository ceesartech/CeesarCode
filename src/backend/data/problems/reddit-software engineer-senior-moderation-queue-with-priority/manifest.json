{
  "ID": "reddit-software engineer-senior-moderation-queue-with-priority",
  "Title": "Moderation Queue with Priority",
  "Statement": "Reddit's moderation system needs to handle flagged content efficiently. Some flagged items might be more critical (e.g., illegal content) than others (e.g., spam). Design and implement a `ModerationQueue` that allows moderators to review flagged content. The queue should prioritize items based on their severity and process them efficiently.",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cvector\u003e\n#include \u003cstring\u003e\n#include \u003cqueue\u003e\n#include \u003cchrono\u003e\n\nstruct FlaggedContent {\n    std::string contentId;\n    int severity; // Higher number = higher priority\n    long long flaggedAt; // Unix timestamp\n\n    // Custom comparator for std::priority_queue (max-heap) to act as needed:\n    // Higher severity first, then older (smaller flaggedAt) first for tie-breaking\n    bool operator\u003c(const FlaggedContent\u0026 other) const {\n        if (severity != other.severity) {\n            return severity \u003c other.severity; // max-heap will put higher severity at top\n        }\n        return flaggedAt \u003e other.flaggedAt; // max-heap will put smaller flaggedAt at top (older first)\n    }\n};\n\nclass ModerationQueue {\nprivate:\n    std::priority_queue\u003cFlaggedContent\u003e queue_;\n\npublic:\n    ModerationQueue() {}\n\n    void addFlaggedContent(const FlaggedContent\u0026 content) {\n        // Your code for Part 1 \u0026 2\n    }\n\n    FlaggedContent getNextForReview() {\n        // Your code for Part 1 \u0026 2\n        return {}; // Return a default or throw if empty\n    }\n};",
    "go": "package main\n\nimport (\n    \"container/heap\"\n    \"sync\"\n)\n\ntype FlaggedContent struct {\n    ContentId string\n    Severity int // Higher number = higher priority\n    FlaggedAt int64 // Unix timestamp\n}\n\n// A min-heap to implement a max-priority queue (higher severity, then older)\ntype ContentPriorityQueue []FlaggedContent\n\nfunc (pq ContentPriorityQueue) Len() int { return len(pq) }\nfunc (pq ContentPriorityQueue) Less(i, j int) bool {\n    if pq[i].Severity != pq[j].Severity {\n        return pq[i].Severity \u003e pq[j].Severity // Max severity first (so use \u003e)\n    }\n    return pq[i].FlaggedAt \u003c pq[j].FlaggedAt // Then oldest first (so use \u003c)\n}\nfunc (pq ContentPriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\n\nfunc (pq *ContentPriorityQueue) Push(x interface{}) {\n    *pq = append(*pq, x.(FlaggedContent))\n}\n\nfunc (pq *ContentPriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    *pq = old[0 : n-1]\n    return item\n}\n\ntype ModerationQueue struct {\n    queue *ContentPriorityQueue\n    mu sync.Mutex\n}\n\nfunc NewModerationQueue() *ModerationQueue {\n    pq := \u0026ContentPriorityQueue{}\n    heap.Init(pq)\n    return \u0026ModerationQueue{queue: pq}\n}\n\nfunc (mq *ModerationQueue) AddFlaggedContent(content FlaggedContent) {\n    // Your code for Part 1 \u0026 2\n}\n\nfunc (mq *ModerationQueue) GetNextForReview() *FlaggedContent {\n    // Your code for Part 1 \u0026 2\n    return nil\n}",
    "java": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\nclass FlaggedContent {\n    String contentId;\n    int severity; // Higher number = higher priority\n    long flaggedAt; // Unix timestamp\n\n    public FlaggedContent(String contentId, int severity, long flaggedAt) {\n        this.contentId = contentId;\n        this.severity = severity;\n        this.flaggedAt = flaggedAt;\n    }\n}\n\nclass ModerationQueue {\n    private PriorityQueue\u003cFlaggedContent\u003e queue;\n\n    public ModerationQueue() {\n        this.queue = new PriorityQueue\u003c\u003e(\n            (c1, c2) -\u003e {\n                if (c1.severity != c2.severity) {\n                    return Integer.compare(c2.severity, c1.severity); // Higher severity first\n                }\n                return Long.compare(c1.flaggedAt, c2.flaggedAt); // Then oldest first\n            }\n        );\n    }\n\n    public void addFlaggedContent(FlaggedContent content) {\n        // Your code for Part 1 \u0026 2\n    }\n\n    public FlaggedContent getNextForReview() {\n        // Your code for Part 1 \u0026 2\n        return null;\n    }\n}",
    "javascript": "class FlaggedContent {\n    constructor(contentId, severity, flaggedAt) {\n        this.contentId = contentId;\n        this.severity = severity;\n        this.flaggedAt = flaggedAt; // Unix timestamp\n    }\n}\n\n// For JavaScript, you'd typically implement a custom Priority Queue or simulate it.\n// For this stub, we'll assume an array and manual sorting for simplicity, or expect a library.\nclass ModerationQueue {\n    constructor() {\n        this.queue = []; // Array of FlaggedContent, to be treated as a priority queue\n    }\n\n    addFlaggedContent(content) {\n        // Your code for Part 1 \u0026 2 (e.g., add to array, then sort or maintain sorted)\n        this.queue.push(content);\n        this.queue.sort((a, b) =\u003e {\n            if (a.severity !== b.severity) {\n                return b.severity - a.severity; // Higher severity first\n            }\n            return a.flaggedAt - b.flaggedAt; // Then oldest first\n        });\n    }\n\n    getNextForReview() {\n        // Your code for Part 1 \u0026 2 (e.g., pop from front of sorted array)\n        if (this.queue.length === 0) return null;\n        return this.queue.shift();\n    }\n}",
    "python": "from typing import List\nimport heapq\n\nclass FlaggedContent:\n    def __init__(self, content_id: str, severity: int, flagged_at: int):\n        self.content_id = content_id\n        self.severity = severity # Higher number = higher priority\n        self.flagged_at = flagged_at # Unix timestamp\n\n    # For use with heapq, define comparison for min-heap. We want max-priority (severity)\n    # For min-heap, store (-severity, flagged_at, content_id)\n    def __lt__(self, other): # For Python's heapq which is min-heap\n        if self.severity != other.severity:\n            return self.severity \u003e other.severity # Higher severity first\n        return self.flagged_at \u003c other.flagged_at # Then oldest first\n\nclass ModerationQueue:\n    def __init__(self):\n        self.queue = [] # type: List[FlaggedContent]\n\n    def add_flagged_content(self, content: FlaggedContent) -\u003e None:\n        # Your code for Part 1 \u0026 2\n        pass\n\n    def get_next_for_review(self) -\u003e FlaggedContent:\n        # Your code for Part 1 \u0026 2\n        pass",
    "rust": "use std::collections::BinaryHeap;\nuse std::cmp::Ordering;\nuse std::time::Instant;\n\n#[derive(Eq, PartialEq, Debug, Clone)]\npub struct FlaggedContent {\n    pub content_id: String,\n    pub severity: i32, // Higher number = higher priority\n    pub flagged_at: Instant, // Using Instant for relative time in Rust\n}\n\n// Implement Ord for FlaggedContent to use with BinaryHeap (max-heap by default in Rust).\n// Higher severity first, then oldest first.\nimpl Ord for FlaggedContent {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        // Compare severity first (descending for max-heap)\n        match self.severity.cmp(\u0026other.severity).reverse() {\n            Ordering::Equal =\u003e {\n                // If severity is equal, compare flagged_at (ascending for oldest first)\n                self.flagged_at.cmp(\u0026other.flagged_at)\n            }\n            other =\u003e other,\n        }\n    }\n}\n\nimpl PartialOrd for FlaggedContent {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\npub struct ModerationQueue {\n    queue: BinaryHeap\u003cFlaggedContent\u003e,\n}\n\nimpl ModerationQueue {\n    pub fn new() -\u003e Self {\n        ModerationQueue { queue: BinaryHeap::new() }\n    }\n\n    pub fn add_flagged_content(\u0026mut self, content: FlaggedContent) {\n        // Your code for Part 1 \u0026 2\n    }\n\n    pub fn get_next_for_review(\u0026mut self) -\u003e Option\u003cFlaggedContent\u003e {\n        // Your code for Part 1 \u0026 2\n        None\n    }\n}"
  },
  "Type": "coding",
  "IsMultiPart": true,
  "Parts": [
    {
      "partNumber": 1,
      "statement": "Implement `add_flagged_content` and `get_next_for_review` methods for the `ModerationQueue` class. Initially, items should be reviewed in a simple FIFO (First-In, First-Out) order. `get_next_for_review` should remove and return the next item, or `None`/`null` if the queue is empty. Consider concurrency if multiple moderators are pulling items.",
      "stub": null
    },
    {
      "partNumber": 2,
      "statement": "Modify the `ModerationQueue` to prioritize items based on their `severity`. Items with higher `severity` should be reviewed before items with lower `severity`. If two items have the same `severity`, the older item (smaller `flagged_at` timestamp) should be reviewed first. Ensure `add_flagged_content` and `get_next_for_review` remain efficient.",
      "stub": null
    },
    {
      "partNumber": 3,
      "statement": "Now, consider that some content can be automatically filtered or quarantined based on predefined rules (e.g., known spam keywords, specific user reputation scores). Extend the `ModerationQueue` with a mechanism to `auto_filter(content: FlaggedContent, rules: List[Rule]) -\u003e Optional[FlaggedContent]`. If the `content` matches any `rule`, it should not be added to the queue for manual review, and `None`/`null` should be returned. Otherwise, return the original `content` to be added to the queue. Define a simple `Rule` class (e.g., `Rule(keyword: str, min_severity: int)`). Discuss how this rule engine could scale and be managed for a large number of dynamic rules.",
      "stub": null
    }
  ]
}