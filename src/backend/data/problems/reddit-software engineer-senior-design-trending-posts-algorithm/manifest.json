{
  "ID": "reddit-software engineer-senior-design-trending-posts-algorithm",
  "Title": "Design Trending Posts Algorithm",
  "Statement": "Reddit's front page often features 'trending' posts, which are not just the highest-scoring but also gaining popularity rapidly. Design an algorithm to identify trending posts within a given time window. The algorithm should prioritize posts that have seen a significant increase in score (net upvotes) recently, rather than just having a high absolute score.\n\nAssume you receive a stream of `PostUpdate` events. Each event contains:\n`{'post_id': \u003cstring\u003e, 'score_change': \u003cint\u003e, 'timestamp': \u003clong_unix_ms\u003e}`\n\nImplement a `TrendingPostsFinder` class with the following methods:\n1.  `__init__(self, trending_window_seconds: int, min_score_to_trend: int)`: Initializes the finder with a time window for trending analysis and a minimum score threshold for posts to be considered.\n2.  `record_update(self, update: dict)`: Processes a `PostUpdate` event.\n3.  `get_trending_posts(self, k: int) -\u003e list[str]`: Returns the top `k` trending `post_id`s, sorted by their trending score (descending).\n\n**Trending Score Calculation:** For this problem, define a post's trending score as the sum of `score_change` events within `trending_window_seconds`. Only posts with a total score (current absolute score) greater than `min_score_to_trend` should be considered for trending.\n\n**Example Usage:**\n1. `finder = TrendingPostsFinder(trending_window_seconds=60, min_score_to_trend=10)`\n2. `finder.record_update({'post_id': 'pA', 'score_change': 5, 'timestamp': 100})`\n3. `finder.record_update({'post_id': 'pB', 'score_change': 15, 'timestamp': 105})`\n4. `finder.record_update({'post_id': 'pA', 'score_change': 8, 'timestamp': 110})`\n5. `finder.record_update({'post_id': 'pC', 'score_change': 2, 'timestamp': 115})`\n6. `finder.get_trending_posts(2)` (assuming current time is 115, pA trending score 13, pB trending score 15, pC trending score 2)\n   -\u003e `['pB', 'pA']` (if their total scores are also \u003e 10)\n\nConsider how to efficiently manage the time window (e.g., removing old updates).",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cvector\u003e\n#include \u003cunordered_map\u003e\n#include \u003cdeque\u003e\n#include \u003calgorithm\u003e\n#include \u003cchrono\u003e\n\nlong long get_current_time_ms() {\n    return std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(\n        std::chrono::system_clock::now().time_since_epoch()\n    ).count();\n}\n\nstruct ScoreUpdate {\n    long long timestamp_ms;\n    int score_change;\n};\n\nclass TrendingPostsFinder {\npublic:\n    TrendingPostsFinder(int trending_window_seconds, int min_score_to_trend) :\n        trending_window_seconds_(trending_window_seconds),\n        min_score_to_trend_(min_score_to_trend) {\n        // Constructor\n    }\n\n    void record_update(const std::string\u0026 post_id, int score_change, long long timestamp_ms) {\n        // Process the score update and manage the window\n    }\n\n    std::vector\u003cstd::string\u003e get_trending_posts(int k) {\n        // Calculate trending scores and return top K posts\n        return {};\n    }\n\nprivate:\n    int trending_window_seconds_;\n    int min_score_to_trend_;\n    std::unordered_map\u003cstd::string, std::deque\u003cScoreUpdate\u003e\u003e post_score_changes_;\n    std::unordered_map\u003cstd::string, int\u003e current_post_scores_;\n};\n",
    "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"container/list\"\n\t\"sort\"\n\t\"sync\"\n)\n\nfunc GetCurrentTime() int64 {\n\treturn time.Now().Unix()\n}\n\ntype ScoreUpdate struct {\n    Timestamp   int64\n    ScoreChange int\n}\n\ntype TrendingPostsFinder struct {\n    TrendingWindowSeconds int\n    MinScoreToTrend       int\n\t\n    // {post_id: list.List of ScoreUpdate}\n    postScoreChanges map[string]*list.List \n    // {post_id: current_total_score}\n    currentPostScores map[string]int\n    mu                sync.Mutex\n}\n\nfunc NewTrendingPostsFinder(trendingWindowSeconds, minScoreToTrend int) *TrendingPostsFinder {\n    return \u0026TrendingPostsFinder{\n        TrendingWindowSeconds: trendingWindowSeconds,\n        MinScoreToTrend:       minScoreToTrend,\n        postScoreChanges:      make(map[string]*list.List),\n        currentPostScores:     make(map[string]int),\n    }\n}\n\nfunc (tpf *TrendingPostsFinder) RecordUpdate(postId string, scoreChange int, timestamp int64) {\n    // Process the score update and manage the window\n}\n\nfunc (tpf *TrendingPostsFinder) GetTrendingPosts(k int) []string {\n    // Calculate trending scores and return top K posts\n    return []string{}\n}",
    "java": "import java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.stream.Collectors;\n\nclass TrendingPostsFinder {\n    private int trendingWindowSeconds;\n    private int minScoreToTrend;\n    \n    // {post_id: Deque\u003cScoreUpdate\u003e}\n    private Map\u003cString, Deque\u003cScoreUpdate\u003e\u003e postScoreChanges;\n    // {post_id: current_total_score}\n    private Map\u003cString, Integer\u003e currentPostScores;\n\n    public TrendingPostsFinder(int trendingWindowSeconds, int minScoreToTrend) {\n        this.trendingWindowSeconds = trendingWindowSeconds;\n        this.minScoreToTrend = minScoreToTrend;\n        this.postScoreChanges = new ConcurrentHashMap\u003c\u003e();\n        this.currentPostScores = new ConcurrentHashMap\u003c\u003e();\n    }\n\n    private long getCurrentTime() {\n        return System.currentTimeMillis() / 1000;\n    }\n\n    static class ScoreUpdate {\n        long timestamp;\n        int scoreChange;\n\n        public ScoreUpdate(long timestamp, int scoreChange) {\n            this.timestamp = timestamp;\n            this.scoreChange = scoreChange;\n        }\n    }\n\n    public void recordUpdate(String postId, int scoreChange, long timestamp) {\n        // Process the score update and manage the window\n    }\n\n    public List\u003cString\u003e getTrendingPosts(int k) {\n        // Calculate trending scores and return top K posts\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "function getCurrentTime() {\n    return Math.floor(Date.now() / 1000);\n}\n\nclass TrendingPostsFinder {\n    constructor(trendingWindowSeconds, minScoreToTrend) {\n        this.trendingWindowSeconds = trendingWindowSeconds;\n        this.minScoreToTrend = minScoreToTrend;\n        // Store all score changes per post within the window\n        this.postScoreChanges = new Map(); // Map\u003cpostId, Deque\u003c[timestamp, score_change]\u003e\u003e\n        // Store current absolute score per post\n        this.currentPostScores = new Map(); // Map\u003cpostId, total_score\u003e\n    }\n\n    recordUpdate(update) {\n        // Process the score update and manage the window\n    }\n\n    getTrendingPosts(k) {\n        // Calculate trending scores and return top K posts\n        return [];\n    }\n}",
    "python": "import time\nimport collections\n\ndef get_current_time():\n    return int(time.time())\n\nclass TrendingPostsFinder:\n    def __init__(self, trending_window_seconds: int, min_score_to_trend: int):\n        self.trending_window_seconds = trending_window_seconds\n        self.min_score_to_trend = min_score_to_trend\n        # Store all score changes per post within the window\n        self.post_score_changes = collections.defaultdict(collections.deque) # {post_id: deque((timestamp, score_change))}\n        # Store current absolute score per post (to check min_score_to_trend)\n        self.current_post_scores = collections.defaultdict(int) # {post_id: total_score}\n\n    def record_update(self, update: dict):\n        # Process the score update and manage the window\n        pass\n\n    def get_trending_posts(self, k: int) -\u003e list[str]:\n        # Calculate trending scores and return top K posts\n        pass",
    "rust": "use std::collections::{HashMap, VecDeque};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\npub fn get_current_time_ms() -\u003e u64 {\n    SystemTime::now().duration_since(UNIX_EPOCH).expect(\"Time went backwards\").as_millis() as u64\n}\n\npub struct ScoreUpdate {\n    timestamp_ms: u64,\n    score_change: i32,\n}\n\npub struct TrendingPostsFinder {\n    trending_window_seconds: u64,\n    min_score_to_trend: i32,\n    // {post_id: VecDeque\u003cScoreUpdate\u003e}\n    post_score_changes: HashMap\u003cString, VecDeque\u003cScoreUpdate\u003e\u003e,\n    // {post_id: current_total_score}\n    current_post_scores: HashMap\u003cString, i32\u003e,\n}\n\nimpl TrendingPostsFinder {\n    pub fn new(trending_window_seconds: u64, min_score_to_trend: i32) -\u003e Self {\n        TrendingPostsFinder {\n            trending_window_seconds,\n            min_score_to_trend,\n            post_score_changes: HashMap::new(),\n            current_post_scores: HashMap::new(),\n        }\n    }\n\n    pub fn record_update(\u0026mut self, post_id: String, score_change: i32, timestamp_ms: u64) {\n        // Process the score update and manage the window\n    }\n\n    pub fn get_trending_posts(\u0026mut self, k: usize) -\u003e Vec\u003cString\u003e {\n        // Calculate trending scores and return top K posts\n        vec![]\n    }\n}"
  },
  "Type": "coding"
}