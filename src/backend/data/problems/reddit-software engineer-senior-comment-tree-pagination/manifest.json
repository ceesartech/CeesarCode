{
  "ID": "reddit-software engineer-senior-comment-tree-pagination",
  "Title": "Comment Tree Flattening and Pagination",
  "Statement": "Reddit comments are often displayed in a nested, tree-like structure. For efficient rendering and pagination, we need to flatten this structure. Given a list of root-level comments, where each comment can have a list of replies (which are also comments, forming a tree), implement a function `get_paginated_comments_for_display(root_comments: list[Comment], page_size: int, page_number: int) -\u003e list[DisplayComment]`. \n\nA `Comment` object has `id: str`, `author: str`, `text: str`, `replies: list[Comment]`. \nA `DisplayComment` object should include `id: str`, `author: str`, `text: str`, and `depth: int` indicating its nesting level.\n\nThe flattening should follow a depth-first traversal order (root, then its first child, then that child's first child, etc.). The pagination should then apply to this flattened list. \n\nExample:\n`C1 (id='c1', replies=[C1_1(id='c1_1', replies=[C1_1_1(id='c1_1_1')]), C1_2(id='c1_2')])`\n`C2 (id='c2')`\n`root_comments = [C1, C2]`\n\nFlattened order (conceptual): `[C1 (d0), C1_1 (d1), C1_1_1 (d2), C1_2 (d1), C2 (d0)]`\n\n`get_paginated_comments_for_display(root_comments, page_size=2, page_number=0)` (1st page):\nOutput: `[DisplayComment(id='c1', depth=0), DisplayComment(id='c1_1', depth=1)]`\n\n`get_paginated_comments_for_display(root_comments, page_size=2, page_number=1)` (2nd page):\nOutput: `[DisplayComment(id='c1_1_1', depth=2), DisplayComment(id='c1_2', depth=1)]`\n\nConstraints:\n- The comment tree depth can be up to 100.\n- Total number of comments can be up to 10,000.\n- `page_size \u003e= 1`, `page_number \u003e= 0`.",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cvector\u003e\n#include \u003calgorithm\u003e\n\nstruct Comment {\n    std::string id;\n    std::string author;\n    std::string text;\n    std::vector\u003cComment\u003e replies;\n\n    Comment(std::string id, std::string author, std::string text, std::vector\u003cComment\u003e replies = {}) \n        : id(std::move(id)), author(std::move(author)), text(std::move(text)), replies(std::move(replies)) {}\n};\n\nstruct DisplayComment {\n    std::string id;\n    std::string author;\n    std::string text;\n    int depth;\n\n    DisplayComment(std::string id, std::string author, std::string text, int depth)\n        : id(std::move(id)), author(std::move(author)), text(std::move(text)), depth(depth) {}\n};\n\nstd::vector\u003cDisplayComment\u003e getPaginatedCommentsForDisplay(\n    const std::vector\u003cComment\u003e\u0026 rootComments, int pageSize, int pageNumber\n) {\n    // Your code here\n    return {};\n}",
    "go": "package main\n\ntype Comment struct {\n\tId      string\n\tAuthor  string\n\tText    string\n\tReplies []Comment\n}\n\ntype DisplayComment struct {\n\tId     string\n\tAuthor string\n\tText   string\n\tDepth  int\n}\n\nfunc GetPaginatedCommentsForDisplay(rootComments []Comment, pageSize, pageNumber int) []DisplayComment {\n\t// Your code here\n\treturn []DisplayComment{}\n}",
    "java": "import java.util.*;\n\nclass Comment {\n    String id;\n    String author;\n    String text;\n    List\u003cComment\u003e replies;\n\n    public Comment(String id, String author, String text, List\u003cComment\u003e replies) {\n        this.id = id;\n        this.author = author;\n        this.text = text;\n        this.replies = replies != null ? replies : new ArrayList\u003c\u003e();\n    }\n}\n\nclass DisplayComment {\n    String id;\n    String author;\n    String text;\n    int depth;\n\n    public DisplayComment(String id, String author, String text, int depth) {\n        this.id = id;\n        this.author = author;\n        this.text = text;\n        this.depth = depth;\n    }\n}\n\nclass CommentService {\n    public List\u003cDisplayComment\u003e getPaginatedCommentsForDisplay(List\u003cComment\u003e rootComments, int pageSize, int pageNumber) {\n        // Your code here\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "class Comment {\n    constructor(id, author, text, replies = []) {\n        this.id = id;\n        this.author = author;\n        this.text = text;\n        this.replies = replies;\n    }\n}\n\nclass DisplayComment {\n    constructor(id, author, text, depth) {\n        this.id = id;\n        this.author = author;\n        this.text = text;\n        this.depth = depth;\n    }\n}\n\nfunction getPaginatedCommentsForDisplay(rootComments, pageSize, pageNumber) {\n    // Your code here\n    return [];\n}",
    "python": "class Comment:\n    def __init__(self, id: str, author: str, text: str, replies: list = None):\n        self.id = id\n        self.author = author\n        self.text = text\n        self.replies = replies if replies is not None else []\n\nclass DisplayComment:\n    def __init__(self, id: str, author: str, text: str, depth: int):\n        self.id = id\n        self.author = author\n        self.text = text\n        self.depth = depth\n    \n    def __eq__(self, other):\n        return self.id == other.id and self.depth == other.depth\n\n    def __repr__(self):\n        return f\"DC(id='{self.id}', depth={self.depth})\"\n\ndef get_paginated_comments_for_display(root_comments: list[Comment], page_size: int, page_number: int) -\u003e list[DisplayComment]:\n    # Your code here\n    return []",
    "rust": "#[derive(Debug, Clone)]\npub struct Comment {\n    pub id: String,\n    pub author: String,\n    pub text: String,\n    pub replies: Vec\u003cComment\u003e,\n}\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct DisplayComment {\n    pub id: String,\n    pub author: String,\n    pub text: String,\n    pub depth: i32,\n}\n\npub fn get_paginated_comments_for_display(\n    root_comments: Vec\u003cComment\u003e, \n    page_size: i32, \n    page_number: i32\n) -\u003e Vec\u003cDisplayComment\u003e {\n    // Your code here\n    vec![]\n}"
  },
  "Type": "coding"
}