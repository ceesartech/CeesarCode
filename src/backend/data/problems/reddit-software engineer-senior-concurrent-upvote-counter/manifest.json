{
  "ID": "reddit-software engineer-senior-concurrent-upvote-counter",
  "Title": "Concurrent Upvote Counter",
  "Statement": "Design and implement a `Post` class that holds upvote and downvote counts. The `upvote()` and `downvote()` methods can be called concurrently by many threads/goroutines/processes. Ensure that the final `get_score()` (calculated as `upvotes - downvotes`) is accurate and that the internal counts are consistent, even under heavy concurrent load.\n\n**Requirements:**\n*   `__init__()` (or equivalent constructor): Initializes a post with 0 upvotes and 0 downvotes.\n*   `upvote()`: Increments the upvote count safely.\n*   `downvote()`: Increments the downvote count safely.\n*   `get_score() -\u003e int`: Returns the current `upvotes - downvotes` count, reflecting all concurrent updates.\n\n**Constraints:**\n*   All methods must be thread-safe.\n*   The solution should be performant under high contention (i.e., many concurrent calls).\n\n**Example (conceptual usage):**\n```python\npost = Post()\n\n# Simulate concurrent calls from multiple threads:\n# For example, using Python's threading module:\nthreads = []\nfor _ in range(50):\n    t = threading.Thread(target=post.upvote)\n    threads.append(t)\nfor _ in range(20):\n    t = threading.Thread(target=post.downvote)\n    threads.append(t)\n\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\n# After all concurrent operations complete:\nassert post.get_score() == 30 # (50 upvotes - 20 downvotes)\n```",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cmutex\u003e\n#include \u003catomic\u003e\n\nclass Post {\nprivate:\n    // Your fields here, consider mutex or atomic operations\npublic:\n    Post() {\n        // Your code here\n    }\n\n    void upvote() {\n        // Your code here\n    }\n\n    void downvote() {\n        // Your code here\n    }\n\n    int getScore() {\n        // Your code here\n        return 0;\n    }\n};",
    "go": "package main\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\ntype Post struct {\n    // Your fields here, consider using sync.Mutex or atomic operations\n}\n\nfunc NewPost() *Post {\n    // Your code here\n    return \u0026Post{}\n}\n\nfunc (p *Post) Upvote() {\n    // Your code here\n}\n\nfunc (p *Post) Downvote() {\n    // Your code here\n}\n\nfunc (p *Post) GetScore() int {\n    // Your code here\n    return 0\n}",
    "java": "import java.util.concurrent.atomic.AtomicInteger;\n\nclass Post {\n    // Your fields here, consider using atomic types or synchronization\n\n    public Post() {\n        // Your code here\n    }\n\n    public void upvote() {\n        // Your code here\n    }\n\n    public void downvote() {\n        // Your code here\n    }\n\n    public int getScore() {\n        // Your code here\n        return 0;\n    }\n}",
    "javascript": "class Post {\n    constructor() {\n        // JavaScript's concurrency model (event loop, single-threaded) means direct multi-threading challenges\n        // like race conditions on shared memory don't apply in the same way as Java/Python/C++.\n        // If this were a Node.js context, you might simulate asynchronous updates.\n        // For this problem, assume synchronous operations within a single execution context.\n        // Or, for a more advanced interpretation, consider how you'd manage state across Web Workers.\n        this.upvotes = 0;\n        this.downvotes = 0;\n    }\n\n    upvote() {\n        this.upvotes++;\n    }\n\n    downvote() {\n        this.downvotes++;\n    }\n\n    getScore() {\n        return this.upvotes - this.downvotes;\n    }\n}",
    "python": "import threading\n\nclass Post:\n    def __init__(self):\n        # Your code here\n        pass\n\n    def upvote(self):\n        # Your code here\n        pass\n\n    def downvote(self):\n        # Your code here\n        pass\n\n    def get_score(self) -\u003e int:\n        # Your code here\n        pass",
    "rust": "use std::sync::{Mutex, Arc, atomic::{AtomicI32, Ordering}};\n\npub struct Post {\n    // Your fields here, consider Arc\u003cMutex\u003c...\u003e\u003e or AtomicI32\n}\n\nimpl Post {\n    pub fn new() -\u003e Self {\n        // Your code here\n        Post {}\n    }\n\n    pub fn upvote(\u0026self) {\n        // Your code here\n    }\n\n    pub fn downvote(\u0026self) {\n        // Your code here\n    }\n\n    pub fn get_score(\u0026self) -\u003e i32 {\n        // Your code here\n        0\n    }\n}"
  },
  "Type": "coding"
}