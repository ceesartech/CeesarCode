{
  "ID": "reddit-software engineer-senior-design-scalable-notification-system",
  "Title": "Design Scalable Notification System",
  "Statement": "Reddit sends various types of notifications to its users (e.g., new comment on your post, a reply to your comment, trending posts in your subscribed subreddits). Design a scalable notification system. Your task is to implement a simplified notification processing engine.\n\nAssume you have:\n-   `User` objects with `id` and `notification_preferences` (e.g., email, push, inbox).\n-   `Event` objects, each with an `event_type` (e.g., 'new_comment', 'post_upvote'), `source_user_id`, `target_user_id` (the recipient of the notification), `related_entity_id` (e.g., post ID, comment ID), and `timestamp`.\n\nImplement a `NotificationProcessor` class with a single method:\n`process_event(event: dict) -\u003e list[dict]` that takes an event and returns a list of `Notification` objects that should be generated. Each `Notification` should contain `recipient_user_id`, `type`, `message`, and `delivery_channels` (based on user preferences).\n\n**Simplifications for the problem:**\n-   Focus on the logic for *generating* notifications based on events and user preferences, not on the actual delivery mechanism.\n-   Assume a `get_user_preferences(user_id)` helper function exists that returns a list of preferred delivery channels (e.g., `['inbox', 'push']`).\n-   Define simple rules for notification messages (e.g., 'New comment on your post from {source_user_id}').\n-   Handle `event_type`s: `new_comment_on_post`, `reply_to_comment`.\n\n**Example Input:**\n`event = {`\n  `'event_type': 'new_comment_on_post',`\n  `'source_user_id': 'uA',`\n  `'target_user_id': 'uB',`\n  `'related_entity_id': 'p123',`\n  `'timestamp': 1678990000`\n`}`\n`get_user_preferences('uB')` returns `['inbox', 'email']`\n\n**Example Output:**\n`[`\n  `{'recipient_user_id': 'uB',`\n  `'type': 'new_comment',`\n  `'message': 'New comment on your post p123 from uA',`\n  `'delivery_channels': ['inbox', 'email']}`\n`]`",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cvector\u003e\n#include \u003cunordered_map\u003e\n#include \u003calgorithm\u003e\n\n// Mock function for user preferences\nstd::vector\u003cstd::string\u003e get_user_preferences(const std::string\u0026 user_id) {\n    static const std::unordered_map\u003cstd::string, std::vector\u003cstd::string\u003e\u003e preferences = {\n        {\"uA\", {\"inbox\"}},\n        {\"uB\", {\"inbox\", \"email\"}},\n        {\"uC\", {\"push\", \"inbox\"}}\n    };\n    auto it = preferences.find(user_id);\n    if (it != preferences.end()) {\n        return it-\u003esecond;\n    }\n    return {\"inbox\"};\n}\n\nstruct Notification {\n    std::string recipient_user_id;\n    std::string type;\n    std::string message;\n    std::vector\u003cstd::string\u003e delivery_channels;\n};\n\nclass NotificationProcessor {\npublic:\n    NotificationProcessor() {\n        // Any initialization for rules or message templates\n    }\n\n    std::vector\u003cNotification\u003e process_event(const std::unordered_map\u003cstd::string, std::string\u003e\u0026 event) {\n        // Process the event and generate notifications\n        return {};\n    }\n};\n",
    "go": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc GetUserPreferences(userId string) []string {\n    preferences := map[string][]string{\n        \"uA\": {\"inbox\"},\n        \"uB\": {\"inbox\", \"email\"},\n        \"uC\": {\"push\", \"inbox\"},\n    }\n    if prefs, ok := preferences[userId]; ok {\n        return prefs\n    }\n    return []string{\"inbox\"}\n}\n\ntype Notification struct {\n    RecipientUserId    string\n    Type               string\n    Message            string\n    DeliveryChannels   []string\n}\n\ntype NotificationProcessor struct {\n    // Any initialization for rules or message templates\n}\n\nfunc NewNotificationProcessor() *NotificationProcessor {\n    return \u0026NotificationProcessor{}\n}\n\nfunc (np *NotificationProcessor) ProcessEvent(event map[string]string) []Notification {\n    // Process the event and generate notifications\n    return []Notification{}\n}",
    "java": "import java.util.*;\n\nclass NotificationProcessor {\n    public List\u003cString\u003e getUserPreferences(String userId) {\n        Map\u003cString, List\u003cString\u003e\u003e preferences = new HashMap\u003c\u003e();\n        preferences.put(\"uA\", Arrays.asList(\"inbox\"));\n        preferences.put(\"uB\", Arrays.asList(\"inbox\", \"email\"));\n        preferences.put(\"uC\", Arrays.asList(\"push\", \"inbox\"));\n        return preferences.getOrDefault(userId, Arrays.asList(\"inbox\"));\n    }\n\n    public NotificationProcessor() {\n        // Any initialization for rules or message templates\n    }\n\n    public List\u003cMap\u003cString, Object\u003e\u003e processEvent(Map\u003cString, Object\u003e event) {\n        // Process the event and generate notifications\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "function getUserPreferences(userId) {\n    const preferences = {\n        'uA': ['inbox'],\n        'uB': ['inbox', 'email'],\n        'uC': ['push', 'inbox']\n    };\n    return preferences[userId] || ['inbox'];\n}\n\nclass NotificationProcessor {\n    constructor() {\n        // Any initialization for rules or message templates\n    }\n\n    processEvent(event) {\n        // Process the event and generate notifications\n        return [];\n    }\n}",
    "python": "def get_user_preferences(user_id: str) -\u003e list[str]:\n    # This is a mock function, in a real system it would query a database\n    preferences = {\n        'uA': ['inbox'],\n        'uB': ['inbox', 'email'],\n        'uC': ['push', 'inbox']\n    }\n    return preferences.get(user_id, ['inbox'])\n\nclass NotificationProcessor:\n    def __init__(self):\n        # Any initialization for rules or message templates\n        pass\n\n    def process_event(self, event: dict) -\u003e list[dict]:\n        # Process the event and generate notifications\n        pass",
    "rust": "use std::collections::HashMap;\n\npub fn get_user_preferences(user_id: \u0026str) -\u003e Vec\u003cString\u003e {\n    let preferences: HashMap\u003cString, Vec\u003cString\u003e\u003e = HashMap::from([\n        (\"uA\".to_string(), vec![\"inbox\".to_string()]),\n        (\"uB\".to_string(), vec![\"inbox\".to_string(), \"email\".to_string()]),\n        (\"uC\".to_string(), vec![\"push\".to_string(), \"inbox\".to_string()]),\n    ]);\n    preferences.get(user_id).cloned().unwrap_or_else(|| vec![\"inbox\".to_string()])\n}\n\npub struct Notification {\n    pub recipient_user_id: String,\n    pub notification_type: String,\n    pub message: String,\n    pub delivery_channels: Vec\u003cString\u003e,\n}\n\npub struct NotificationProcessor {\n    // Any initialization for rules or message templates\n}\n\nimpl NotificationProcessor {\n    pub fn new() -\u003e Self {\n        NotificationProcessor {}\n    }\n\n    pub fn process_event(\u0026self, event: \u0026HashMap\u003cString, String\u003e) -\u003e Vec\u003cNotification\u003e {\n        // Process the event and generate notifications\n        vec![]\n    }\n}"
  },
  "Type": "coding"
}