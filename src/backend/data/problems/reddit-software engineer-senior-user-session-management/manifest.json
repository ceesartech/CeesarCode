{
  "ID": "reddit-software engineer-senior-user-session-management",
  "Title": "User Session Management",
  "Statement": "Reddit users need to maintain their logged-in state across requests and devices securely. Design and implement a `SessionManager` that handles user sessions.\n\n**Part 1: Basic Session Management**\nImplement a `SessionManager` class with the following methods:\n-   `create_session(user_id: str, expiration_seconds: int) -\u003e str`: Creates a new session for a `user_id`, sets an `expiration_seconds`, and returns a unique `session_token`.\n-   `validate_session(session_token: str) -\u003e str | None`: Checks if a `session_token` is valid and not expired. If valid, returns the `user_id`; otherwise, returns `None`.\n\nAssume `get_current_time()` is available and returns the current Unix timestamp in seconds.\n\n**Constraints:**\n-   `session_token`s must be unique and difficult to guess.\n-   Session creation and validation must be efficient.\n\n**Example Usage (Part 1):**\n1. `sm = SessionManager()`\n2. `token1 = sm.create_session('userA', 3600)`\n3. `sm.validate_session(token1)` -\u003e `'userA'`\n4. (After 3600 seconds)\n5. `sm.validate_session(token1)` -\u003e `None`",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cunordered_map\u003e\n#include \u003cchrono\u003e\n#include \u003crandom\u003e\n#include \u003cmutex\u003e\n\nlong long get_current_time() {\n    return std::chrono::duration_cast\u003cstd::chrono::seconds\u003e(\n        std::chrono::system_clock::now().time_since_epoch()\n    ).count();\n}\n\nclass SessionManager {\npublic:\n    SessionManager() {\n        // Initialize data structures\n    }\n\n    std::string create_session(const std::string\u0026 user_id, int expiration_seconds) {\n        // Generate a secure session token and store it with user_id and expiry\n        return \"\";\n    }\n\n    std::string validate_session(const std::string\u0026 session_token) {\n        // Validate the token and check expiry\n        return \"\"; // Return empty string for None\n    }\n\nprivate:\n    // Your data structures to store session information\n    // Use std::mutex for thread safety\n};\n",
    "go": "package main\n\nimport (\n\t\"time\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"sync\"\n)\n\nfunc GetCurrentTime() int64 {\n\treturn time.Now().Unix()\n}\n\ntype SessionManager struct {\n    // Your data structures to store session information\n    mu sync.RWMutex\n}\n\nfunc NewSessionManager() *SessionManager {\n    // Initialize data structures\n\treturn \u0026SessionManager{}\n}\n\nfunc (sm *SessionManager) CreateSession(userId string, expirationSeconds int) string {\n    // Generate a secure session token and store it with user_id and expiry\n    return \"\"\n}\n\nfunc (sm *SessionManager) ValidateSession(sessionToken string) string {\n    // Validate the token and check expiry\n    return \"\" // Return empty string for None\n}",
    "java": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\nclass SessionManager {\n    public long getCurrentTime() {\n        return System.currentTimeMillis() / 1000;\n    }\n\n    // Your data structures to store session information\n\n    public SessionManager() {\n        // Initialize data structures\n    }\n\n    public String createSession(String userId, int expirationSeconds) {\n        // Generate a secure session token and store it with user_id and expiry\n        return null;\n    }\n\n    public String validateSession(String sessionToken) {\n        // Validate the token and check expiry\n        return null;\n    }\n}",
    "javascript": "function getCurrentTime() {\n    return Math.floor(Date.now() / 1000);\n}\n\nclass SessionManager {\n    constructor() {\n        // Your data structures to store session information\n    }\n\n    createSession(userId, expirationSeconds) {\n        // Generate a secure session token and store it with user_id and expiry\n        return null;\n    }\n\n    validateSession(sessionToken) {\n        // Validate the token and check expiry\n        return null;\n    }\n}",
    "python": "import time\nimport os\nimport base64\n\ndef get_current_time():\n    return int(time.time())\n\nclass SessionManager:\n    def __init__(self):\n        # Your data structures to store session information\n        pass\n\n    def create_session(self, user_id: str, expiration_seconds: int) -\u003e str:\n        # Generate a secure session token and store it with user_id and expiry\n        pass\n\n    def validate_session(self, session_token: str) -\u003e str | None:\n        # Validate the token and check expiry\n        pass",
    "rust": "use std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse rand::RngCore;\nuse base64::{engine::general_purpose, Engine as _};\n\npub fn get_current_time() -\u003e u64 {\n    SystemTime::now().duration_since(UNIX_EPOCH).expect(\"Time went backwards\").as_secs()\n}\n\npub struct SessionManager {\n    // Your data structures to store session information\n}\n\nimpl SessionManager {\n    pub fn new() -\u003e Self {\n        // Initialize data structures\n        SessionManager {}\n    }\n\n    pub fn create_session(\u0026mut self, user_id: String, expiration_seconds: u64) -\u003e String {\n        // Generate a secure session token and store it with user_id and expiry\n        String::new()\n    }\n\n    pub fn validate_session(\u0026self, session_token: \u0026str) -\u003e Option\u003cString\u003e {\n        // Validate the token and check expiry\n        None\n    }\n}"
  },
  "Type": "coding"
}