{
  "ID": "reddit-software engineer-senior-user-karma-leaderboard",
  "Title": "User Karma Tracking and Leaderboard",
  "Statement": "Reddit users accumulate 'karma' based on upvotes on their posts and comments. Implement a `KarmaTracker` class to manage user karma and provide a real-time leaderboard.\n1.  `update_karma(user_id: str, karma_change: int)`: Adds `karma_change` (positive for upvotes, negative for downvotes) to `user_id`'s total karma. `karma_change` can be any integer.\n2.  `get_top_karma_users(num_users: int) -\u003e list[tuple[str, int]]`: Returns a list of the top `num_users` with the highest karma, ordered from highest to lowest. Each element in the list should be a `(user_id, karma_score)` tuple.\n\nOptimize `get_top_karma_users` for efficiency, as it might be called frequently and the number of users can be very large, while `num_users` is relatively small. Break ties in karma score arbitrarily (e.g., alphabetically by user ID).\n\nExample:\n`tracker = KarmaTracker()`\n`tracker.update_karma('Alice', 100)`\n`tracker.update_karma('Bob', 150)`\n`tracker.update_karma('Alice', 20)`\n`tracker.update_karma('Charlie', 80)`\n`tracker.get_top_karma_users(2)` -\u003e `[('Bob', 150), ('Alice', 120)]`\n\nConstraints:\n- Number of unique users can be up to 1,000,000.\n- `karma_change` ranges from -1000 to 1000.\n- `num_users` up to 100.",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cvector\u003e\n#include \u003cunordered_map\u003e\n#include \u003cqueue\u003e\n#include \u003calgorithm\u003e\n\nclass KarmaTracker {\npublic:\n    KarmaTracker() {\n        // Your code here\n    }\n\n    void updateKarma(const std::string\u0026 userId, int karmaChange) {\n        // Your code here\n    }\n\n    std::vector\u003cstd::pair\u003cstd::string, int\u003e\u003e getTopKarmaUsers(int numUsers) {\n        // Your code here\n        return {};\n    }\n};\n",
    "go": "package main\n\nimport (\n\t\"container/heap\"\n\t\"sync\"\n)\n\ntype UserKarma struct {\n\tUserId string\n\tKarma  int\n}\n\n// Min-heap for top users\ntype UserKarmaHeap []UserKarma\n\nfunc (h UserKarmaHeap) Len() int            { return len(h) }\nfunc (h UserKarmaHeap) Less(i, j int) bool  { return h[i].Karma \u003c h[j].Karma }\nfunc (h UserKarmaHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\n\nfunc (h *UserKarmaHeap) Push(x interface{}) {\n\t*h = append(*h, x.(UserKarma))\n}\n\nfunc (h *UserKarmaHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\ntype KarmaTracker struct {\n\t// Your code here\n}\n\nfunc NewKarmaTracker() *KarmaTracker {\n\treturn \u0026KarmaTracker{\n\t\t// Your code here\t\n\t}\n}\n\nfunc (kt *KarmaTracker) UpdateKarma(userId string, karmaChange int) {\n\t// Your code here\n}\n\nfunc (kt *KarmaTracker) GetTopKarmaUsers(numUsers int) []UserKarma {\n\t// Your code here\n\treturn []UserKarma{}\n}",
    "java": "import java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\nclass KarmaTracker {\n    private Map\u003cString, Integer\u003e userKarma;\n\n    public KarmaTracker() {\n        this.userKarma = new ConcurrentHashMap\u003c\u003e();\n    }\n\n    public void updateKarma(String userId, int karmaChange) {\n        // Your code here\n    }\n\n    public List\u003cMap.Entry\u003cString, Integer\u003e\u003e getTopKarmaUsers(int numUsers) {\n        // Your code here\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "class KarmaTracker {\n    constructor() {\n        // Your code here\n    }\n\n    updateKarma(userId, karmaChange) {\n        // Your code here\n    }\n\n    getTopKarmaUsers(numUsers) {\n        // Your code here\n        return [];\n    }\n}",
    "python": "import heapq\nimport collections\n\nclass KarmaTracker:\n    def __init__(self):\n        # Your code here\n        pass\n\n    def update_karma(self, user_id: str, karma_change: int):\n        # Your code here\n        pass\n\n    def get_top_karma_users(self, num_users: int) -\u003e list[tuple[str, int]]:\n        # Your code here\n        return []",
    "rust": "use std::collections::HashMap;\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\nuse std::sync::{Arc, Mutex};\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct UserKarma {\n    pub user_id: String,\n    pub karma: i32,\n}\n\n// Min-heap for top users: prioritize lower karma (for keeping only top N)\nimpl Ord for UserKarma {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        other.karma.cmp(\u0026self.karma) // Invert for max-heap behavior on karma\n            .then_with(|| self.user_id.cmp(\u0026other.user_id)) // Tie-break by user_id for consistent ordering\n    }\n}\n\nimpl PartialOrd for UserKarma {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\npub struct KarmaTracker {\n    // Your code here\n}\n\nimpl KarmaTracker {\n    pub fn new() -\u003e Self {\n        KarmaTracker {\n            // Your code here\n        }\n    }\n\n    pub fn update_karma(\u0026mut self, user_id: String, karma_change: i32) {\n        // Your code here\n    }\n\n    pub fn get_top_karma_users(\u0026self, num_users: i32) -\u003e Vec\u003cUserKarma\u003e {\n        // Your code here\n        vec![]\n    }\n}"
  },
  "Type": "coding"
}