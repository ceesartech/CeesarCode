{
  "ID": "reddit-software engineer-senior-nearest-location-search",
  "Title": "Nearest Location Search for Geo-tagged Posts",
  "Statement": "Imagine Reddit wants to display posts that are geographically relevant to a user, perhaps for local events or community news. Design and implement a system that can efficiently find the `N` nearest posts to a given geographical coordinate. For simplicity, assume post locations are represented as (latitude, longitude) pairs.\n\n`PostLocation` class:\n`post_id` (string)\n`latitude` (float)\n`longitude` (float)\n\n`LocationSearcher` class methods:\n- `__init__(self)`: Initializes the searcher.\n- `add_post(self, post_location: PostLocation)`: Adds a new post with its location to the system.\n- `find_nearest_posts(self, query_latitude: float, query_longitude: float, N: int) -\u003e List[str]`: Returns a list of `post_id`s for the `N` nearest posts to the query coordinates, sorted by distance in ascending order. If fewer than `N` posts exist, return all of them.\n\nDistance calculation: Use Euclidean distance for simplicity (or Haversine if feeling ambitious, but Euclidean is fine for this problem statement).\nEuclidean distance between (lat1, lon1) and (lat2, lon2) = `sqrt((lat2-lat1)^2 + (lon2-lon1)^2)`\n\nConstraints:\n- Many posts can be added (millions).\n- `find_nearest_posts` must be efficient for real-time queries.\n\nExample:\nsearcher = LocationSearcher()\nsearcher.add_post(PostLocation(\"p1\", 34.0, -118.0)) # Los Angeles\nsearcher.add_post(PostLocation(\"p2\", 40.7, -74.0))  # New York\nsearcher.add_post(PostLocation(\"p3\", 34.1, -118.1)) # Near LA\nsearcher.add_post(PostLocation(\"p4\", 33.9, -117.9)) # Near LA\n\n`find_nearest_posts(34.05, -118.05, 2)` (query near LA)\n\nDistances to (34.05, -118.05):\n- p1 (34.0, -118.0): sqrt((34.05-34.0)^2 + (-118.05 - (-118.0))^2) = sqrt(0.0025 + 0.0025) = sqrt(0.005) approx 0.0707\n- p2 (40.7, -74.0): (very far)\n- p3 (34.1, -118.1): sqrt((34.05-34.1)^2 + (-118.05 - (-118.1))^2) = sqrt(0.0025 + 0.0025) = sqrt(0.005) approx 0.0707\n- p4 (33.9, -117.9): sqrt((34.05-33.9)^2 + (-118.05 - (-117.9))^2) = sqrt(0.0225 + 0.0225) = sqrt(0.045) approx 0.2121\n\nOutput: [\"p1\", \"p3\"] (order doesn't matter for equal distances, but sorted by distance in general)",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cvector\u003e\n#include \u003cstring\u003e\n#include \u003ccmath\u003e\n#include \u003calgorithm\u003e\n#include \u003cqueue\u003e\n#include \u003cmap\u003e\n\nstruct PostLocation {\n    std::string postId;\n    double latitude;\n    double longitude;\n};\n\nclass LocationSearcher {\nprivate:\n    std::vector\u003cPostLocation\u003e posts_; // Could be a spatial data structure\n\n    double calculateDistance(double lat1, double lon1, double lat2, double lon2) const {\n        return std::sqrt(std::pow(lat2 - lat1, 2) + std::pow(lon2 - lon1, 2));\n    }\n\npublic:\n    LocationSearcher() {}\n\n    void addPost(const PostLocation\u0026 postLocation) {\n        // Your code here\n    }\n\n    std::vector\u003cstd::string\u003e findNearestPosts(double queryLatitude, double queryLongitude, int N) {\n        // Your code here (consider a spatial data structure for efficiency)\n        return {};\n    }\n};",
    "go": "package main\n\nimport (\n    \"math\"\n    \"sort\"\n)\n\ntype PostLocation struct {\n    PostId string\n    Latitude float64\n    Longitude float64\n}\n\ntype LocationSearcher struct {\n    posts []PostLocation // Could be a spatial data structure\n}\n\nfunc NewLocationSearcher() *LocationSearcher {\n    return \u0026LocationSearcher{\n        posts: []PostLocation{},\n    }\n}\n\nfunc (ls *LocationSearcher) AddPost(postLocation PostLocation) {\n    // Your code here\n}\n\nfunc (ls *LocationSearcher) calculateDistance(lat1, lon1, lat2, lon2 float64) float64 {\n    return math.Sqrt(math.Pow(lat2 - lat1, 2) + math.Pow(lon2 - lon1, 2))\n}\n\nfunc (ls *LocationSearcher) FindNearestPosts(queryLatitude, queryLongitude float64, N int) []string {\n    // Your code here (consider a spatial data structure for efficiency)\n    return []string{}\n}",
    "java": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\nclass PostLocation {\n    String postId;\n    double latitude;\n    double longitude;\n\n    public PostLocation(String postId, double latitude, double longitude) {\n        this.postId = postId;\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n}\n\nclass LocationSearcher {\n    private List\u003cPostLocation\u003e posts; // Could be a spatial data structure\n\n    public LocationSearcher() {\n        this.posts = new ArrayList\u003c\u003e();\n    }\n\n    public void addPost(PostLocation postLocation) {\n        // Your code here\n    }\n\n    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {\n        // Euclidean distance for simplicity\n        return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lon2 - lon1, 2));\n    }\n\n    public List\u003cString\u003e findNearestPosts(double queryLatitude, double queryLongitude, int N) {\n        // Your code here (consider a spatial data structure for efficiency)\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "class PostLocation {\n    constructor(postId, latitude, longitude) {\n        this.postId = postId;\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n}\n\nclass LocationSearcher {\n    constructor() {\n        this.posts = []; // Could be a spatial data structure\n    }\n\n    add_post(postLocation) {\n        // Your code here\n    }\n\n    _calculateDistance(lat1, lon1, lat2, lon2) {\n        return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lon2 - lon1, 2));\n    }\n\n    find_nearest_posts(queryLatitude, queryLongitude, N) {\n        // Your code here (consider a spatial data structure like a KD-Tree or Quadtree for efficiency)\n        return [];\n    }\n}",
    "python": "from typing import List\nimport math\n\nclass PostLocation:\n    def __init__(self, post_id: str, latitude: float, longitude: float):\n        self.post_id = post_id\n        self.latitude = latitude\n        self.longitude = longitude\n\nclass LocationSearcher:\n    def __init__(self):\n        self.posts = [] # type: List[PostLocation]\n\n    def add_post(self, post_location: PostLocation) -\u003e None:\n        # Your code here\n        pass\n\n    def find_nearest_posts(self, query_latitude: float, query_longitude: float, N: int) -\u003e List[str]:\n        # Your code here (consider using a spatial data structure like a KD-Tree or Quadtree for efficiency)\n        pass",
    "rust": "use std::collections::BinaryHeap;\nuse std::cmp::Ordering;\n\npub struct PostLocation {\n    pub post_id: String,\n    pub latitude: f64,\n    pub longitude: f64,\n}\n\n// Helper for priority queue: distance and post ID.\n// We want a min-heap for distance, so we'll implement Ord appropriately.\nstruct PostDistance\u003c'a\u003e {\n    distance: f64,\n    post_id: \u0026'a str,\n}\n\nimpl\u003c'a\u003e PartialEq for PostDistance\u003c'a\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.distance.partial_cmp(\u0026other.distance).unwrap_or(Ordering::Equal) == Ordering::Equal \u0026\u0026 self.post_id == other.post_id\n    }\n}\n\nimpl\u003c'a\u003e Eq for PostDistance\u003c'a\u003e {}\n\nimpl\u003c'a\u003e Ord for PostDistance\u003c'a\u003e {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        // For a min-heap, invert the float comparison. Handle NaNs/infinities carefully.\n        other.distance.partial_cmp(\u0026self.distance).unwrap_or_else(|| {\n            if self.distance.is_nan() \u0026\u0026 other.distance.is_nan() { Ordering::Equal }\n            else if self.distance.is_nan() { Ordering::Greater }\n            else { Ordering::Less }\n        })\n    }\n}\n\nimpl\u003c'a\u003e PartialOrd for PostDistance\u003c'a\u003e {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\npub struct LocationSearcher {\n    posts: Vec\u003cPostLocation\u003e, // Could be a spatial data structure like a k-d tree\n}\n\nimpl LocationSearcher {\n    pub fn new() -\u003e Self {\n        LocationSearcher { posts: Vec::new() }\n    }\n\n    pub fn add_post(\u0026mut self, post_location: PostLocation) {\n        // Your code here\n    }\n\n    fn calculate_distance(lat1: f64, lon1: f64, lat2: f64, lon2: f64) -\u003e f64 {\n        ((lat2 - lat1).powi(2) + (lon2 - lon1).powi(2)).sqrt()\n    }\n\n    pub fn find_nearest_posts(\u0026self, query_latitude: f64, query_longitude: f64, n: usize) -\u003e Vec\u003cString\u003e {\n        // Your code here (consider a spatial data structure for efficiency)\n        vec![]\n    }\n}"
  },
  "Type": "coding"
}