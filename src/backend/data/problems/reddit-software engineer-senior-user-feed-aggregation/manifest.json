{
  "ID": "reddit-software engineer-senior-user-feed-aggregation",
  "Title": "Personalized User Feed Aggregation",
  "Statement": "Part 1: As a Reddit user, you subscribe to various subreddits. Your 'Home' feed should show you a personalized stream of posts. Implement a function `get_user_feed(user_id: str, num_posts: int)` that returns the `num_posts` most recent posts from all subreddits the `user_id` is subscribed to. Assume you have access to two external (and potentially slow) APIs:\n`get_subscribed_subreddits(user_id: str) -\u003e list[str]` which returns a list of subreddit IDs.\n`get_recent_posts_in_subreddit(subreddit_id: str, limit: int) -\u003e list[Post]` which returns `limit` most recent `Post` objects from a given subreddit. A `Post` object has `id: str`, `subreddit_id: str`, `title: str`, `timestamp: long`, `upvotes: int`.\n\nYour implementation should efficiently merge posts from multiple subreddits to produce the overall most recent `num_posts`.\n\nExample:\nUser 'Alice' subscribes to `r/news` and `r/programming`.\n`get_subscribed_subreddits('Alice')` returns `['r/news', 'r/programming']`\n`get_recent_posts_in_subreddit('r/news', 5)` returns `[P_news_1(ts=100), P_news_2(ts=90)]`\n`get_recent_posts_in_subreddit('r/programming', 5)` returns `[P_prog_1(ts=105), P_prog_2(ts=95)]`\n`get_user_feed('Alice', 3)` should return `[P_prog_1, P_news_1, P_prog_2]` (ordered by timestamp descending)\n\nConstraints:\n- `num_posts` up to 100.\n- `get_subscribed_subreddits` can return up to 1000 subreddits.\n- `get_recent_posts_in_subreddit` can return up to 50 posts.",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cvector\u003e\n#include \u003cqueue\u003e\n#include \u003cunordered_map\u003e\n\nstruct Post {\n    std::string id;\n    std::string subredditId;\n    std::string title;\n    long long timestamp;\n    int upvotes;\n\n    // For max-heap: prioritize higher timestamp\n    bool operator\u003c(const Post\u0026 other) const {\n        return timestamp \u003c other.timestamp;\n    }\n};\n\n// Simulate API calls\nstd::vector\u003cstd::string\u003e getSubscribedSubreddits(const std::string\u0026 userId) {\n    if (userId == \"Alice\") {\n        return {\"r/news\", \"r/programming\"};\n    }\n    return {};\n}\n\nstd::vector\u003cPost\u003e getRecentPostsInSubreddit(const std::string\u0026 subredditId, int limit) {\n    if (subredditId == \"r/news\") {\n        return {\n            {\"Pn1\", \"r/news\", \"News Post 1\", 100LL, 100},\n            {\"Pn2\", \"r/news\", \"News Post 2\", 90LL, 50}\n        };\n    } else if (subredditId == \"r/programming\") {\n        return {\n            {\"Pp1\", \"r/programming\", \"Prog Post 1\", 105LL, 150},\n            {\"Pp2\", \"r/programming\", \"Prog Post 2\", 95LL, 80}\n        };\n    }\n    return {};\n}\n\nstd::vector\u003cPost\u003e getUserFeed(const std::string\u0026 userId, int numPosts) {\n    // Your code here\n    return {};\n}",
    "go": "package main\n\nimport (\n\t\"container/heap\"\n)\n\ntype Post struct {\n\tId          string\n\tSubredditId string\n\tTitle       string\n\tTimestamp   int64\n\tUpvotes     int\n}\n\n// Max-heap for posts (ordered by timestamp for merging logic)\ntype PostHeap []Post\n\nfunc (h PostHeap) Len() int           { return len(h) }\nfunc (h PostHeap) Less(i, j int) bool { return h[i].Timestamp \u003e h[j].Timestamp } \nfunc (h PostHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *PostHeap) Push(x interface{}) {\n\t*h = append(*h, x.(Post))\n}\n\nfunc (h *PostHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\n// Simulate API calls\nfunc getSubscribedSubreddits(userId string) []string {\n\tif userId == \"Alice\" {\n\t\treturn []string{\"r/news\", \"r/programming\"}\n\t}\n\treturn []string{}\n}\n\nfunc getRecentPostsInSubreddit(subredditId string, limit int) []Post {\n\tif subredditId == \"r/news\" {\n\t\treturn []Post{\n\t\t\t{Id: \"Pn1\", SubredditId: \"r/news\", Title: \"News Post 1\", Timestamp: 100, Upvotes: 100},\n\t\t\t{Id: \"Pn2\", SubredditId: \"r/news\", Title: \"News Post 2\", Timestamp: 90, Upvotes: 50},\n\t\t}\n\t} else if subredditId == \"r/programming\" {\n\t\treturn []Post{\n\t\t\t{Id: \"Pp1\", SubredditId: \"r/programming\", Title: \"Prog Post 1\", Timestamp: 105, Upvotes: 150},\n\t\t\t{Id: \"Pp2\", SubredditId: \"r/programming\", Title: \"Prog Post 2\", Timestamp: 95, Upvotes: 80},\n\t\t}\n\t}\n\treturn []Post{}\n}\n\nfunc GetUserFeed(userId string, numPosts int) []Post {\n\t// Your code here\n\treturn []Post{}\n}",
    "java": "import java.util.*;\n\nclass Post {\n    String id;\n    String subredditId;\n    String title;\n    long timestamp;\n    int upvotes;\n\n    public Post(String id, String subredditId, String title, long timestamp, int upvotes) {\n        this.id = id;\n        this.subredditId = subredditId;\n        this.title = title;\n        this.timestamp = timestamp;\n        this.upvotes = upvotes;\n    }\n}\n\nclass FeedService {\n    // Simulate API calls\n    private List\u003cString\u003e getSubscribedSubreddits(String userId) {\n        if (userId.equals(\"Alice\")) {\n            return Arrays.asList(\"r/news\", \"r/programming\");\n        }\n        return new ArrayList\u003c\u003e();\n    }\n\n    private List\u003cPost\u003e getRecentPostsInSubreddit(String subredditId, int limit) {\n        if (subredditId.equals(\"r/news\")) {\n            return Arrays.asList(\n                new Post(\"Pn1\", \"r/news\", \"News Post 1\", 100L, 100),\n                new Post(\"Pn2\", \"r/news\", \"News Post 2\", 90L, 50)\n            );\n        } else if (subredditId.equals(\"r/programming\")) {\n            return Arrays.asList(\n                new Post(\"Pp1\", \"r/programming\", \"Prog Post 1\", 105L, 150),\n                new Post(\"Pp2\", \"r/programming\", \"Prog Post 2\", 95L, 80)\n            );\n        }\n        return new ArrayList\u003c\u003e();\n    }\n\n    public List\u003cPost\u003e getUserFeed(String userId, int numPosts) {\n        // Your code here\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "class Post {\n    constructor(id, subredditId, title, timestamp, upvotes) {\n        this.id = id;\n        this.subredditId = subredditId;\n        this.title = title;\n        this.timestamp = timestamp;\n        this.upvotes = upvotes;\n    }\n}\n\nfunction getSubscribedSubreddits(userId) {\n    if (userId === 'Alice') {\n        return ['r/news', 'r/programming'];\n    }\n    return [];\n}\n\nfunction getRecentPostsInSubreddit(subredditId, limit) {\n    if (subredditId === 'r/news') {\n        return [\n            new Post('Pn1', 'r/news', 'News Post 1', 100, 100),\n            new Post('Pn2', 'r/news', 'News Post 2', 90, 50)\n        ];\n    } else if (subredditId === 'r/programming') {\n        return [\n            new Post('Pp1', 'r/programming', 'Prog Post 1', 105, 150),\n            new Post('Pp2', 'r/programming', 'Prog Post 2', 95, 80)\n        ];\n    }\n    return [];\n}\n\nfunction getUserFeed(userId, numPosts) {\n    // Your code here\n    return [];\n}",
    "python": "import heapq\n\nclass Post:\n    def __init__(self, id: str, subreddit_id: str, title: str, timestamp: int, upvotes: int):\n        self.id = id\n        self.subreddit_id = subreddit_id\n        self.title = title\n        self.timestamp = timestamp\n        self.upvotes = upvotes\n    \n    def __lt__(self, other): # For max-heap behavior (ordering by latest timestamp)\n        return self.timestamp \u003e other.timestamp\n\ndef get_subscribed_subreddits(user_id: str) -\u003e list[str]:\n    # Simulate API call\n    if user_id == 'Alice':\n        return ['r/news', 'r/programming']\n    return []\n\ndef get_recent_posts_in_subreddit(subreddit_id: str, limit: int) -\u003e list[Post]:\n    # Simulate API call\n    if subreddit_id == 'r/news':\n        return [Post('Pn1', 'r/news', 'News Post 1', 100, 100), Post('Pn2', 'r/news', 'News Post 2', 90, 50)]\n    elif subreddit_id == 'r/programming':\n        return [Post('Pp1', 'r/programming', 'Prog Post 1', 105, 150), Post('Pp2', 'r/programming', 'Prog Post 2', 95, 80)]\n    return []\n\n\ndef get_user_feed(user_id: str, num_posts: int) -\u003e list[Post]:\n    # Your code here\n    return []",
    "rust": "use std::collections::BinaryHeap;\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct Post {\n    pub id: String,\n    pub subreddit_id: String,\n    pub title: String,\n    pub timestamp: i64,\n    pub upvotes: i32,\n}\n\n// Custom comparison for BinaryHeap (max-heap on timestamp)\nimpl Ord for Post {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        self.timestamp.cmp(\u0026other.timestamp)\n    }\n}\n\nimpl PartialOrd for Post {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\n// Simulate API calls\npub fn get_subscribed_subreddits(user_id: \u0026str) -\u003e Vec\u003cString\u003e {\n    if user_id == \"Alice\" {\n        vec![\"r/news\".to_string(), \"r/programming\".to_string()]\n    }\n    vec![]\n}\n\npub fn get_recent_posts_in_subreddit(subreddit_id: \u0026str, limit: i32) -\u003e Vec\u003cPost\u003e {\n    if subreddit_id == \"r/news\" {\n        vec![\n            Post { id: \"Pn1\".to_string(), subreddit_id: \"r/news\".to_string(), title: \"News Post 1\".to_string(), timestamp: 100, upvotes: 100 },\n            Post { id: \"Pn2\".to_string(), subreddit_id: \"r/news\".to_string(), title: \"News Post 2\".to_string(), timestamp: 90, upvotes: 50 },\n        ]\n    } else if subreddit_id == \"r/programming\" {\n        vec![\n            Post { id: \"Pp1\".to_string(), subreddit_id: \"r/programming\".to_string(), title: \"Prog Post 1\".to_string(), timestamp: 105, upvotes: 150 },\n            Post { id: \"Pp2\".to_string(), subreddit_id: \"r/programming\".to_string(), title: \"Prog Post 2\".to_string(), timestamp: 95, upvotes: 80 },\n        ]\n    }\n    vec![]\n}\n\npub fn get_user_feed(user_id: \u0026str, num_posts: i32) -\u003e Vec\u003cPost\u003e {\n    // Your code here\n    vec![]\n}"
  },
  "Type": "coding",
  "IsMultiPart": true,
  "Parts": [
    {
      "partNumber": 2,
      "statement": "Part 2: Enhance `get_user_feed` to rank posts based on a 'hotness' score instead of just recency. The hotness score for a post can be calculated as `score = (post.upvotes + 1) / ((current_time_seconds - post.timestamp_seconds) / 3600.0 + 2)^decay_factor`. Assume `current_time_seconds` is the time when `get_user_feed` is called, and `decay_factor` is a configurable parameter (e.g., `0.8`). The goal is to surface posts that are recent AND popular. Update the `Post` class to include a `score` method or field and modify `get_user_feed` to use this for ranking.\n\nExample:\nUsing the posts from Part 1, assume `current_time_seconds=110`, `decay_factor=0.8`.\n`P_news_1`: `(100+1) / ((110-100)/3600.0 + 2)^0.8 = 101 / (0.0027 + 2)^0.8 ≈ 101 / 1.74 ≈ 58.0`\n`P_news_2`: `(50+1) / ((110-90)/3600.0 + 2)^0.8 = 51 / (0.0055 + 2)^0.8 ≈ 51 / 1.74 ≈ 29.3`\n`P_prog_1`: `(150+1) / ((110-105)/3600.0 + 2)^0.8 = 151 / (0.0013 + 2)^0.8 ≈ 151 / 1.74 ≈ 86.8`\n`P_prog_2`: `(80+1) / ((110-95)/3600.0 + 2)^0.8 = 81 / (0.0041 + 2)^0.8 ≈ 81 / 1.74 ≈ 46.5`\n`get_user_feed('Alice', 3)` (ranked by hotness): `[P_prog_1, P_news_1, P_prog_2]`",
      "stub": null
    },
    {
      "partNumber": 3,
      "statement": "Part 3: Discuss how this personalized feed generation system would scale to support millions of users and billions of posts, with posts being created and upvoted constantly. Consider the implications of calling `get_recent_posts_in_subreddit` potentially hundreds of times. Propose architectural changes and optimizations (e.g., caching, pre-computation, stream processing, fan-out/fan-in strategies, materialized views) that Reddit would use. Outline a high-level API design for a dedicated 'Feed Service'. The coding component should focus on how the `get_user_feed` function's internal logic would change to interact with a highly optimized, potentially distributed 'Feed Backend' (e.g., `self.feed_backend.get_precomputed_feed(user_id, num_posts, ranking_algo='hot')`), rather than making direct API calls to many subreddits.",
      "stub": null
    }
  ]
}