{
  "ID": "reddit-software engineer-senior-api-rate-limiter",
  "Title": "API Rate Limiter",
  "Statement": "Reddit's APIs handle a massive volume of requests and need robust rate limiting to prevent abuse and ensure fair access. Implement a `RateLimiter` class that can enforce different rate limits for different users and API endpoints. The rate limiter should support a 'token bucket' or 'leaky bucket' algorithm.\n\nYour `RateLimiter` class should have:\n- An `__init__` method that can configure global or default rate limits.\n- A `configure_endpoint(endpoint_name, max_requests, time_window_seconds)` method to set specific limits for an endpoint.\n- A `configure_user_endpoint(user_id, endpoint_name, max_requests, time_window_seconds)` method to set specific limits for a user on an endpoint (user-specific limits should override endpoint-specific limits).\n- A `should_allow_request(user_id, endpoint_name)` method that returns `True` if the request is allowed and `False` otherwise. If allowed, it should consume a token.\n\nConsider how to handle concurrent requests in a multi-threaded or distributed environment, even if your implementation is single-threaded for now, explain your thoughts on distribution.\n\n**Example Usage:**\n1. `rl = RateLimiter(default_max_requests=5, default_time_window=60)`\n2. `rl.configure_endpoint('/api/posts', 10, 60)` (10 requests per minute for posts)\n3. `rl.configure_user_endpoint('user123', '/api/posts', 2, 10)` (user123 can only make 2 requests every 10 seconds for posts)\n4. `rl.should_allow_request('user123', '/api/posts')` -\u003e `True`\n5. `rl.should_allow_request('user123', '/api/posts')` -\u003e `True`\n6. `rl.should_allow_request('user123', '/api/posts')` -\u003e `False` (user123 hit their limit)\n7. `rl.should_allow_request('other_user', '/api/posts')` -\u003e `True` (other_user uses default for endpoint)\n\nAssume current time can be obtained via a `get_current_time()` helper function returning seconds since epoch.",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cchrono\u003e\n#include \u003cmutex\u003e\n#include \u003cunordered_map\u003e\n\n// Helper for current time in seconds\nlong long get_current_time() {\n    return std::chrono::duration_cast\u003cstd::chrono::seconds\u003e(\n        std::chrono::system_clock::now().time_since_epoch()\n    ).count();\n}\n\nclass RateLimiter {\npublic:\n    RateLimiter(int default_max_requests, int default_time_window_seconds) {\n        // Your initialization logic\n    }\n\n    void configure_endpoint(const std::string\u0026 endpoint_name, int max_requests, int time_window_seconds) {\n        // Configure endpoint-specific limits\n    }\n\n    void configure_user_endpoint(const std::string\u0026 user_id, const std::string\u0026 endpoint_name, int max_requests, int time_window_seconds) {\n        // Configure user-endpoint specific limits\n    }\n\n    bool should_allow_request(const std::string\u0026 user_id, const std::string\u0026 endpoint_name) {\n        // Determine if request is allowed and consume token if true\n        return false;\n    }\n\nprivate:\n    // Your data structures\n    std::mutex mtx_;\n};\n",
    "go": "package main\n\nimport (\n\t\"time\"\n)\n\nfunc GetCurrentTime() int64 {\n\treturn time.Now().Unix()\n}\n\ntype RateLimiter struct {\n    // Your data structures\n}\n\nfunc NewRateLimiter(defaultMaxRequests, defaultTimeWindow int) *RateLimiter {\n    // Your initialization logic\t\n\treturn \u0026RateLimiter{}\n}\n\nfunc (rl *RateLimiter) ConfigureEndpoint(endpointName string, maxRequests, timeWindowSeconds int) {\n    // Configure endpoint-specific limits\n}\n\nfunc (rl *RateLimiter) ConfigureUserEndpoint(userId, endpointName string, maxRequests, timeWindowSeconds int) {\n    // Configure user-endpoint specific limits\n}\n\nfunc (rl *RateLimiter) ShouldAllowRequest(userId, endpointName string) bool {\n    // Determine if request is allowed and consume token if true\n    return false\n}",
    "java": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.Map;\n\nclass RateLimiter {\n    public long getCurrentTime() {\n        return System.currentTimeMillis() / 1000;\n    }\n\n    public RateLimiter(int defaultMaxRequests, int defaultTimeWindow) {\n        // Your initialization logic\n    }\n\n    public void configureEndpoint(String endpointName, int maxRequests, int timeWindowSeconds) {\n        // Configure endpoint-specific limits\n    }\n\n    public void configureUserEndpoint(String userId, String endpointName, int maxRequests, int timeWindowSeconds) {\n        // Configure user-endpoint specific limits\n    }\n\n    public boolean shouldAllowRequest(String userId, String endpointName) {\n        // Determine if request is allowed and consume token if true\n        return false;\n    }\n}",
    "javascript": "function getCurrentTime() {\n    return Math.floor(Date.now() / 1000);\n}\n\nclass RateLimiter {\n    constructor(defaultMaxRequests, defaultTimeWindow) {\n        // Your initialization logic\n    }\n\n    configureEndpoint(endpointName, maxRequests, timeWindowSeconds) {\n        // Configure endpoint-specific limits\n    }\n\n    configureUserEndpoint(userId, endpointName, maxRequests, timeWindowSeconds) {\n        // Configure user-endpoint specific limits\n    }\n\n    shouldAllowRequest(userId, endpointName) {\n        // Determine if request is allowed and consume token if true\n        return false;\n    }\n}",
    "python": "import time\n\ndef get_current_time():\n    return int(time.time())\n\nclass RateLimiter:\n    def __init__(self, default_max_requests: int, default_time_window: int):\n        # Your initialization logic\n        pass\n\n    def configure_endpoint(self, endpoint_name: str, max_requests: int, time_window_seconds: int):\n        # Configure endpoint-specific limits\n        pass\n\n    def configure_user_endpoint(self, user_id: str, endpoint_name: str, max_requests: int, time_window_seconds: int):\n        # Configure user-endpoint specific limits\n        pass\n\n    def should_allow_request(self, user_id: str, endpoint_name: str) -\u003e bool:\n        # Determine if request is allowed and consume token if true\n        pass",
    "rust": "use std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\npub fn get_current_time() -\u003e u64 {\n    SystemTime::now().duration_since(UNIX_EPOCH).expect(\"Time went backwards\").as_secs()\n}\n\npub struct RateLimiter {\n    // Your data structures\n}\n\nimpl RateLimiter {\n    pub fn new(default_max_requests: i32, default_time_window_seconds: i32) -\u003e Self {\n        // Your initialization logic\n        RateLimiter {}\n    }\n\n    pub fn configure_endpoint(\u0026mut self, endpoint_name: \u0026str, max_requests: i32, time_window_seconds: i32) {\n        // Configure endpoint-specific limits\n    }\n\n    pub fn configure_user_endpoint(\u0026mut self, user_id: \u0026str, endpoint_name: \u0026str, max_requests: i32, time_window_seconds: i32) {\n        // Configure user-endpoint specific limits\n    }\n\n    pub fn should_allow_request(\u0026mut self, user_id: \u0026str, endpoint_name: \u0026str) -\u003e bool {\n        // Determine if request is allowed and consume token if true\n        false\n    }\n}"
  },
  "Type": "coding"
}