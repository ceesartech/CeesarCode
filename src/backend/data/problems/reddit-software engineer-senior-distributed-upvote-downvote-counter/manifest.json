{
  "ID": "reddit-software engineer-senior-distributed-upvote-downvote-counter",
  "Title": "Distributed Upvote/Downvote Counter",
  "Statement": "Reddit posts and comments receive millions of upvotes and downvotes daily. Design and implement a highly available and eventually consistent distributed counter system for these votes. You need to implement a `VoteCounter` class/service that supports `upvote(entity_id)`, `downvote(entity_id)`, and `get_score(entity_id)` operations.\n\nAssume you have multiple instances of `VoteCounter` running on different servers. When `upvote` or `downvote` is called on any instance, the changes should eventually propagate to all other instances and be reflected in `get_score`. Your solution should handle concurrent calls and network partitions gracefully.\n\nFor simplicity, you can simulate the distributed aspect by having a conceptual `Node` identifier for each `VoteCounter` instance and passing it to the vote operations (e.g., `upvote(entity_id, node_id)`).\n\n**Constraints:**\n- `entity_id` is a string.\n- `get_score` should return an integer representing `upvotes - downvotes`.\n- Prioritize availability and eventual consistency over strong consistency.\n\n**Example Usage:**\n1. `counter_node_A = VoteCounter('NodeA')`\n2. `counter_node_B = VoteCounter('NodeB')`\n3. `counter_node_A.upvote('post1')`\n4. `counter_node_A.upvote('post1')`\n5. `counter_node_B.downvote('post1')`\n6. `counter_node_A.get_score('post1')` -\u003e should eventually be 1\n7. `counter_node_B.get_score('post1')` -\u003e should eventually be 1\n\nExplain your choice of data structure and synchronization mechanism.",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cunordered_map\u003e\n#include \u003catomic\u003e\n\nclass VoteCounter {\npublic:\n    VoteCounter(const std::string\u0026 node_id) : node_id_(node_id) {\n        // Initialize data structures\n    }\n\n    void upvote(const std::string\u0026 entity_id) {\n        // Implement upvote logic\n    }\n\n    void downvote(const std::string\u0026 entity_id) {\n        // Implement downvote logic\n    }\n\n    int get_score(const std::string\u0026 entity_id) {\n        // Implement get_score logic, considering eventual consistency\n        return 0;\n    }\n\n    void sync_with_node(const std::unordered_map\u003cstd::string, /* Your Data Type */\u003e\u0026 other_node_data) {\n        // A method to simulate syncing state with another node\n    }\n\nprivate:\n    std::string node_id_;\n    // Your data structures for tracking votes, potentially per-node\n};\n",
    "go": "package main\n\ntype VoteCounter struct {\n    NodeId string\n    // Your data structures for tracking votes, potentially per-node\n}\n\nfunc NewVoteCounter(nodeId string) *VoteCounter {\n    vc := \u0026VoteCounter{\n        NodeId: nodeId,\n        // Initialize data structures\n    }\n    return vc\n}\n\nfunc (vc *VoteCounter) Upvote(entityId string) {\n    // Implement upvote logic\n}\n\nfunc (vc *VoteCounter) Downvote(entityId string) {\n    // Implement downvote logic\n}\n\nfunc (vc *VoteCounter) GetScore(entityId string) int {\n    // Implement get_score logic, considering eventual consistency\n    return 0\n}\n\nfunc (vc *VoteCounter) SyncWithNode(otherNodeData map[string]interface{}) {\n    // A method to simulate syncing state with another node\n}",
    "java": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.Map;\n\nclass VoteCounter {\n    private String nodeId;\n    // Your data structures for tracking votes, potentially per-node\n\n    public VoteCounter(String nodeId) {\n        this.nodeId = nodeId;\n        // Initialize data structures\n    }\n\n    public void upvote(String entityId) {\n        // Implement upvote logic\n    }\n\n    public void downvote(String entityId) {\n        // Implement downvote logic\n    }\n\n    public int getScore(String entityId) {\n        // Implement get_score logic, considering eventual consistency\n        return 0;\n    }\n\n    public void syncWithNode(Map\u003cString, ?\u003e otherNodeData) {\n        // A method to simulate syncing state with another node\n    }\n}",
    "javascript": "class VoteCounter {\n    constructor(nodeId) {\n        this.nodeId = nodeId;\n        // Your data structures for tracking votes, potentially per-node\n    }\n\n    upvote(entityId) {\n        // Implement upvote logic\n    }\n\n    downvote(entityId) {\n        // Implement downvote logic\n    }\n\n    getScore(entityId) {\n        // Implement get_score logic, considering eventual consistency\n        return 0;\n    }\n\n    syncWithNode(otherNodeData) {\n        // A method to simulate syncing state with another node\n    }\n}",
    "python": "class VoteCounter:\n    def __init__(self, node_id: str):\n        self.node_id = node_id\n        # Your data structures for tracking votes, potentially per-node\n\n    def upvote(self, entity_id: str):\n        # Implement upvote logic\n        pass\n\n    def downvote(self, entity_id: str):\n        # Implement downvote logic\n        pass\n\n    def get_score(self, entity_id: str) -\u003e int:\n        # Implement get_score logic, considering eventual consistency\n        pass\n\n    def sync_with_node(self, other_node_data: dict):\n        # A method to simulate syncing state with another node\n        pass",
    "rust": "use std::collections::HashMap;\n\npub struct VoteCounter {\n    node_id: String,\n    // Your data structures for tracking votes, potentially per-node\n}\n\nimpl VoteCounter {\n    pub fn new(node_id: String) -\u003e Self {\n        VoteCounter {\n            node_id,\n            // Initialize data structures\n        }\n    }\n\n    pub fn upvote(\u0026mut self, entity_id: \u0026str) {\n        // Implement upvote logic\n    }\n\n    pub fn downvote(\u0026mut self, entity_id: \u0026str) {\n        // Implement downvote logic\n    }\n\n    pub fn get_score(\u0026self, entity_id: \u0026str) -\u003e i32 {\n        // Implement get_score logic, considering eventual consistency\n        0\n    }\n\n    pub fn sync_with_node(\u0026mut self, other_node_data: HashMap\u003cString, String\u003e) {\n        // A method to simulate syncing state with another node\n    }\n}"
  },
  "Type": "coding"
}