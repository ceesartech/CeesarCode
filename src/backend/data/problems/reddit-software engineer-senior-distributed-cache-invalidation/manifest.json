{
  "ID": "reddit-software engineer-senior-distributed-cache-invalidation",
  "Title": "Distributed Cache Invalidation",
  "Statement": "Reddit serves millions of users, and a significant portion of content is cached for performance. When a post or comment is updated (e.g., new votes, new comments, moderation action), its cached representations across a distributed caching layer must be invalidated to ensure users see the most up-to-date content. Design and describe a system for efficient distributed cache invalidation.\n\nImplement a simplified `CacheManager` class that simulates this behavior across multiple 'cache nodes'.\n\nYour `CacheManager` should support:\n1.  `put(cache_node_id, key, value)`: Stores a value with a key on a specific cache node.\n2.  `get(cache_node_id, key)`: Retrieves a value from a specific cache node. If the item is marked as invalidated, it should simulate fetching it from the 'origin' (e.g., database) and then re-caching it.\n3.  `invalidate_key(key)`: Triggers a global invalidation for the given key across all registered cache nodes.\n\n**Assumptions:**\n-   You can simulate multiple cache nodes (e.g., by creating multiple `CacheManager` instances or by passing `cache_node_id`).\n-   The 'origin' (database) is always up-to-date.\n-   You can assume a communication mechanism (e.g., a shared queue or direct method calls) exists to propagate invalidation messages between cache nodes.\n\n**Example Usage:**\n1. `cm1 = CacheManager('node1')`\n2. `cm2 = CacheManager('node2')`\n3. `cm1.put('node1', 'post:123', 'initial content')`\n4. `cm2.put('node2', 'post:123', 'initial content')`\n5. `cm1.get('node1', 'post:123')` -\u003e 'initial content'\n6. `cm2.get('node2', 'post:123')` -\u003e 'initial content'\n7. `cm1.invalidate_key('post:123')` (This should notify all relevant nodes)\n8. `cm2.get('node2', 'post:123')` -\u003e (Should trigger 'origin' fetch, then return updated content)\n\nExplain the design choices for handling communication and eventual consistency.",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cstring\u003e\n#include \u003cunordered_map\u003e\n#include \u003cunordered_set\u003e\n#include \u003ciostream\u003e\n#include \u003cmutex\u003e\n\n// Forward declaration for inter-node communication simulation\nclass CacheManager;\n\nclass CacheManager {\npublic:\n    CacheManager(const std::string\u0026 node_id) : node_id_(node_id) {\n        // Constructor\n    }\n\n    std::string _fetch_from_origin(const std::string\u0026 key) {\n        std::cout \u003c\u003c \"Node \" \u003c\u003c node_id_ \u003c\u003c \": Fetching '\" \u003c\u003c key \u003c\u003c \"' from origin...\" \u003c\u003c std::endl;\n        return \"updated_content_for_\" + key;\n    }\n\n    void put(const std::string\u0026 key, const std::string\u0026 value) {\n        std::lock_guard\u003cstd::mutex\u003e lock(mtx_);\n        cache_[key] = value;\n        std::cout \u003c\u003c \"Node \" \u003c\u003c node_id_ \u003c\u003c \": Stored '\" \u003c\u003c key \u003c\u003c \"' -\u003e '\" \u003c\u003c value \u003c\u003c \"'\" \u003c\u003c std::endl;\n    }\n\n    std::string get(const std::string\u0026 key) {\n        std::lock_guard\u003cstd::mutex\u003e lock(mtx_);\n        if (invalidated_keys_.count(key) || cache_.find(key) == cache_.end()) {\n            std::cout \u003c\u003c \"Node \" \u003c\u003c node_id_ \u003c\u003c \": '\" \u003c\u003c key \u003c\u003c \"' is invalid or not found. Re-fetching.\" \u003c\u003c std::endl;\n            std::string new_value = _fetch_from_origin(key);\n            cache_[key] = new_value;\n            invalidated_keys_.erase(key);\n            return new_value;\n        }\n        std::cout \u003c\u003c \"Node \" \u003c\u003c node_id_ \u003c\u003c \": Retrieved '\" \u003c\u003c key \u003c\u003c \"' -\u003e '\" \u003c\u003c cache_[key] \u003c\u003c \"'\" \u003c\u003c std::endl;\n        return cache_[key];\n    }\n\n    void invalidate_key(const std::string\u0026 key) {\n        std::cout \u003c\u003c \"Node \" \u003c\u003c node_id_ \u003c\u003c \": Initiating invalidation for '\" \u003c\u003c key \u003c\u003c \"' across cluster.\" \u003c\u003c std::endl;\n        // Simulate communication to other nodes.\n        // In a real system, this would publish to a message queue or a pub/sub system.\n    }\n\n    void receive_invalidation_message(const std::string\u0026 key) {\n        std::lock_guard\u003cstd::mutex\u003e lock(mtx_);\n        invalidated_keys_.insert(key);\n        std::cout \u003c\u003c \"Node \" \u003c\u003c node_id_ \u003c\u003c \": Received invalidation for '\" \u003c\u003c key \u003c\u003c \"'.\" \u003c\u003c std::endl;\n    }\n\nprivate:\n    std::string node_id_;\n    std::unordered_map\u003cstd::string, std::string\u003e cache_;\n    std::unordered_set\u003cstd::string\u003e invalidated_keys_;\n    std::mutex mtx_;\n};\n",
    "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype CacheManager struct {\n    NodeId           string\n    cache            map[string]string\n    invalidatedKeys  map[string]struct{}\n    mu               sync.Mutex // Protects cache and invalidatedKeys\n}\n\nfunc NewCacheManager(nodeId string) *CacheManager {\n    return \u0026CacheManager{\n        NodeId:           nodeId,\n        cache:            make(map[string]string),\n        invalidatedKeys:  make(map[string]struct{}),\n    }\n}\n\nfunc (cm *CacheManager) fetchFromOrigin(key string) string {\n    fmt.Printf(\"Node %s: Fetching '%s' from origin...\\n\", cm.NodeId, key)\n    return fmt.Sprintf(\"updated_content_for_%s\", key)\n}\n\nfunc (cm *CacheManager) Put(key string, value string) {\n    cm.mu.Lock()\n    defer cm.mu.Unlock()\n    cm.cache[key] = value\n    fmt.Printf(\"Node %s: Stored '%s' -\u003e '%s'\\n\", cm.NodeId, key, value)\n}\n\nfunc (cm *CacheManager) Get(key string) string {\n    cm.mu.Lock()\n    defer cm.mu.Unlock()\n\t\n    _, isInvalid := cm.invalidatedKeys[key]\n    _, existsInCache := cm.cache[key]\n\n    if isInvalid || !existsInCache {\n        fmt.Printf(\"Node %s: '%s' is invalid or not found. Re-fetching.\\n\", cm.NodeId, key)\n        newValue := cm.fetchFromOrigin(key)\n        cm.cache[key] = newValue\n        delete(cm.invalidatedKeys, key)\n        return newValue\n    }\n    fmt.Printf(\"Node %s: Retrieved '%s' -\u003e '%s'\\n\", cm.NodeId, key, cm.cache[key])\n    return cm.cache[key]\n}\n\nfunc (cm *CacheManager) InvalidateKey(key string) {\n    fmt.Printf(\"Node %s: Initiating invalidation for '%s' across cluster.\\n\", cm.NodeId, key)\n    // This method needs to communicate with other nodes. For simulation,\n    // you can call a method on other CacheManager instances directly.\n}\n\nfunc (cm *CacheManager) ReceiveInvalidationMessage(key string) {\n    cm.mu.Lock()\n    defer cm.mu.Unlock()\n    cm.invalidatedKeys[key] = struct{}{}\n    fmt.Printf(\"Node %s: Received invalidation for '%s'.\\n\", cm.NodeId, key)\n}",
    "java": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentSkipListSet;\nimport java.util.Set;\nimport java.util.Map;\n\nclass CacheManager {\n    private String nodeId;\n    private Map\u003cString, String\u003e cache;\n    private Set\u003cString\u003e invalidatedKeys;\n\n    public CacheManager(String nodeId) {\n        this.nodeId = nodeId;\n        this.cache = new ConcurrentHashMap\u003c\u003e();\n        this.invalidatedKeys = ConcurrentSkipListSet.newConcurrentSkipListSet();\n    }\n\n    private String fetchFromOrigin(String key) {\n        System.out.println(String.format(\"Node %s: Fetching '%s' from origin...\", this.nodeId, key));\n        return String.format(\"updated_content_for_%s\", key);\n    }\n\n    public void put(String key, String value) {\n        cache.put(key, value);\n        System.out.println(String.format(\"Node %s: Stored '%s' -\u003e '%s'\", this.nodeId, key, value));\n    }\n\n    public String get(String key) {\n        if (invalidatedKeys.contains(key) || !cache.containsKey(key)) {\n            System.out.println(String.format(\"Node %s: '%s' is invalid or not found. Re-fetching.\", this.nodeId, key));\n            String newValue = fetchFromOrigin(key);\n            cache.put(key, newValue);\n            invalidatedKeys.remove(key);\n            return newValue;\n        }\n        System.out.println(String.format(\"Node %s: Retrieved '%s' -\u003e '%s'\", this.nodeId, key, cache.get(key)));\n        return cache.get(key);\n    }\n\n    public void invalidateKey(String key) {\n        System.out.println(String.format(\"Node %s: Initiating invalidation for '%s' across cluster.\", this.nodeId, key));\n        // Simulate communication to other nodes:\n        // For testing, you might call receiveInvalidationMessage on other CacheManager instances here.\n    }\n\n    public void receiveInvalidationMessage(String key) {\n        invalidatedKeys.add(key);\n        System.out.println(String.format(\"Node %s: Received invalidation for '%s'.\", this.nodeId, key));\n    }\n}",
    "javascript": "class CacheManager {\n    constructor(nodeId) {\n        this.nodeId = nodeId;\n        this.cache = {};\n        this.invalidatedKeys = new Set();\n        // You may need a mechanism to register other nodes or a central message bus\n    }\n\n    _fetchFromOrigin(key) {\n        console.log(`Node ${this.nodeId}: Fetching '${key}' from origin...`);\n        return `updated_content_for_${key}`;\n    }\n\n    put(key, value) {\n        this.cache[key] = value;\n        console.log(`Node ${this.nodeId}: Stored '${key}' -\u003e '${value}'`);\n    }\n\n    get(key) {\n        if (this.invalidatedKeys.has(key) || !(key in this.cache)) {\n            console.log(`Node ${this.nodeId}: '${key}' is invalid or not found. Re-fetching.`);\n            const newValue = this._fetchFromOrigin(key);\n            this.cache[key] = newValue;\n            this.invalidatedKeys.delete(key);\n            return newValue;\n        }\n        console.log(`Node ${this.nodeId}: Retrieved '${key}' -\u003e '${this.cache[key]}'`);\n        return this.cache[key];\n    }\n\n    invalidateKey(key) {\n        console.log(`Node ${this.nodeId}: Initiating invalidation for '${key}' across cluster.`);\n        // This method needs to communicate with other nodes. For simulation, \n        // you can call a method on other CacheManager instances directly.\n    }\n\n    receiveInvalidationMessage(key) {\n        this.invalidatedKeys.add(key);\n        console.log(`Node ${this.nodeId}: Received invalidation for '${key}'.`);\n    }\n}",
    "python": "class CacheManager:\n    def __init__(self, node_id: str):\n        self.node_id = node_id\n        self.cache = {}\n        self.invalidated_keys = set() # Keys marked for invalidation on this node\n        # You may need a mechanism to register other nodes or a central message bus\n\n    def _fetch_from_origin(self, key: str) -\u003e str:\n        # Simulate fetching from a database/origin for invalidated items\n        print(f\"Node {self.node_id}: Fetching '{key}' from origin...\")\n        return f\"updated_content_for_{key}\"\n\n    def put(self, key: str, value: str):\n        self.cache[key] = value\n        print(f\"Node {self.node_id}: Stored '{key}' -\u003e '{value}'\")\n\n    def get(self, key: str) -\u003e str:\n        if key in self.invalidated_keys or key not in self.cache:\n            print(f\"Node {self.node_id}: '{key}' is invalid or not found. Re-fetching.\")\n            new_value = self._fetch_from_origin(key)\n            self.cache[key] = new_value\n            if key in self.invalidated_keys:\n                self.invalidated_keys.remove(key)\n            return new_value\n        print(f\"Node {self.node_id}: Retrieved '{key}' -\u003e '{self.cache[key]}'\")\n        return self.cache[key]\n\n    def invalidate_key(self, key: str):\n        # This method needs to communicate with other nodes. For simulation, \n        # you can call a method on other CacheManager instances directly.\n        print(f\"Node {self.node_id}: Initiating invalidation for '{key}' across cluster.\")\n        # How would this message be sent and processed by other nodes?\n\n    def receive_invalidation_message(self, key: str):\n        # This method is called when another node sends an invalidation request\n        self.invalidated_keys.add(key)\n        print(f\"Node {self.node_id}: Received invalidation for '{key}'.\")",
    "rust": "use std::collections::{HashMap, HashSet};\nuse std::sync::{Arc, Mutex};\n\npub struct CacheManager {\n    node_id: String,\n    cache: HashMap\u003cString, String\u003e,\n    invalidated_keys: HashSet\u003cString\u003e,\n}\n\nimpl CacheManager {\n    pub fn new(node_id: String) -\u003e Self {\n        CacheManager {\n            node_id,\n            cache: HashMap::new(),\n            invalidated_keys: HashSet::new(),\n        }\n    }\n\n    fn fetch_from_origin(\u0026self, key: \u0026str) -\u003e String {\n        println!(\"Node {}: Fetching '{}' from origin...\", self.node_id, key);\n        format!(\"updated_content_for_{}\", key)\n    }\n\n    pub fn put(\u0026mut self, key: String, value: String) {\n        self.cache.insert(key.clone(), value.clone());\n        println!(\"Node {}: Stored '{}' -\u003e '{}'\", self.node_id, key, value);\n    }\n\n    pub fn get(\u0026mut self, key: \u0026str) -\u003e String {\n        if self.invalidated_keys.contains(key) || !self.cache.contains_key(key) {\n            println!(\"Node {}: '{}' is invalid or not found. Re-fetching.\", self.node_id, key);\n            let new_value = self.fetch_from_origin(key);\n            self.cache.insert(key.to_string(), new_value.clone());\n            self.invalidated_keys.remove(key);\n            return new_value;\n        }\n        let value = self.cache.get(key).unwrap().clone();\n        println!(\"Node {}: Retrieved '{}' -\u003e '{}'\", self.node_id, key, value);\n        value\n    }\n\n    pub fn invalidate_key(\u0026self, key: \u0026str) {\n        println!(\"Node {}: Initiating invalidation for '{}' across cluster.\", self.node_id, key);\n        // This method needs to communicate with other nodes. For simulation,\n        // you might pass `Arc\u003cMutex\u003cCacheManager\u003e\u003e` to other nodes and call their receive method.\n    }\n\n    pub fn receive_invalidation_message(\u0026mut self, key: \u0026str) {\n        self.invalidated_keys.insert(key.to_string());\n        println!(\"Node {}: Received invalidation for '{}'.\", self.node_id, key);\n    }\n}"
  },
  "Type": "coding"
}