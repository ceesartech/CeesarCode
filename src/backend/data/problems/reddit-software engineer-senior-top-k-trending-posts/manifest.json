{
  "ID": "reddit-software engineer-senior-top-k-trending-posts",
  "Title": "Top K Trending Posts from a Stream",
  "Statement": "Reddit's 'trending' or 'popular' feeds require continuously tracking the most active or highest-scoring posts. Imagine a system that receives a stream of `PostUpdate` events, each containing a `post_id` and its current `score` (e.g., `upvotes - downvotes`). Design and implement a class `TrendingPostsTracker` that can efficiently maintain and retrieve the `k` posts with the highest scores at any given time.\n\n`PostUpdate` class:\n`post_id` (string)\n`score` (integer)\n\n`TrendingPostsTracker` class methods:\n- `__init__(self, k: int)`: Initializes the tracker to maintain the top `k` posts.\n- `update_post_score(self, post_update: PostUpdate)`: Processes a new score update for a post. If the post doesn't exist, it's added. If it exists, its score is updated.\n- `get_top_k_posts(self) -\u003e List[str]`: Returns a list of `post_id`s for the top `k` posts, sorted by score in descending order. If fewer than `k` posts exist, return all of them.\n\nConstraints:\n- The number of posts can be very large.\n- `update_post_score` should be efficient (logarithmic or better).\n- `get_top_k_posts` should also be efficient.\n\nExample:\ntracker = TrendingPostsTracker(k=2)\n\ntracker.update_post_score(PostUpdate(\"p1\", 10))\ntracker.update_post_score(PostUpdate(\"p2\", 5))\nprint(tracker.get_top_k_posts()) # Output: [\"p1\", \"p2\"]\n\ntracker.update_post_score(PostUpdate(\"p3\", 12))\nprint(tracker.get_top_k_posts()) # Output: [\"p3\", \"p1\"]\n\ntracker.update_post_score(PostUpdate(\"p1\", 8))\nprint(tracker.get_top_k_posts()) # Output: [\"p3\", \"p1\"] (p1 score changed but still higher than p2)\n\ntracker.update_post_score(PostUpdate(\"p4\", 15))\nprint(tracker.get_top_k_posts()) # Output: [\"p4\", \"p3\"]",
  "Languages": [
    "python",
    "java",
    "cpp",
    "javascript",
    "go",
    "rust"
  ],
  "Stub": {
    "cpp": "#include \u003cvector\u003e\n#include \u003cstring\u003e\n#include \u003cunordered_map\u003e\n#include \u003cqueue\u003e\n#include \u003calgorithm\u003e\n\nstruct PostUpdate {\n    std::string postId;\n    int score;\n\n    // For priority queue, min-heap stores smallest at top. We want top K largest, so store (score, postId)\n    // Custom comparator for min-heap of PostUpdate objects based on score\n    bool operator\u003e(const PostUpdate\u0026 other) const {\n        return score \u003e other.score;\n    }\n};\n\nclass TrendingPostsTracker {\nprivate:\n    int k_;\n    std::unordered_map\u003cstd::string, int\u003e postScores_; // Stores current score for each post_id\n    std::priority_queue\u003cPostUpdate, std::vector\u003cPostUpdate\u003e, std::greater\u003cPostUpdate\u003e\u003e minHeap_; // Min-heap to store top K\n\npublic:\n    TrendingPostsTracker(int k) : k_(k) {}\n\n    void updatePostScore(const PostUpdate\u0026 postUpdate) {\n        // Your code here\n    }\n\n    std::vector\u003cstd::string\u003e getTopKPosts() {\n        // Your code here\n        return {};\n    }\n};",
    "go": "package main\n\nimport (\n    \"container/heap\"\n    \"sync\"\n)\n\ntype PostUpdate struct {\n    PostId string\n    Score int\n}\n\n// A MinHeap implements heap.Interface and holds PostUpdates.\ntype PostUpdateMinHeap []PostUpdate\n\nfunc (h PostUpdateMinHeap) Len() int           { return len(h) }\nfunc (h PostUpdateMinHeap) Less(i, j int) bool { return h[i].Score \u003c h[j].Score }\nfunc (h PostUpdateMinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *PostUpdateMinHeap) Push(x interface{}) { *h = append(*h, x.(PostUpdate)) }\nfunc (h *PostUpdateMinHeap) Pop() interface{}   {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\ntype TrendingPostsTracker struct {\n    k int\n    postScores map[string]int // Stores current score for each post_id\n    minHeap *PostUpdateMinHeap // Min-heap to store top K\n    postHeapMap map[string]*PostUpdate // To quickly find post in heap for updates\n    mu sync.Mutex\n}\n\nfunc NewTrendingPostsTracker(k int) *TrendingPostsTracker {\n    h := \u0026PostUpdateMinHeap{}\n    heap.Init(h)\n    return \u0026TrendingPostsTracker{\n        k: k,\n        postScores: make(map[string]int),\n        minHeap: h,\n        postHeapMap: make(map[string]*PostUpdate),\n    }\n}\n\nfunc (tpt *TrendingPostsTracker) UpdatePostScore(postUpdate PostUpdate) {\n    // Your code here\n}\n\nfunc (tpt *TrendingPostsTracker) GetTopKPosts() []string {\n    // Your code here\n    return []string{}\n}",
    "java": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\nclass PostUpdate {\n    String postId;\n    int score;\n\n    public PostUpdate(String postId, int score) {\n        this.postId = postId;\n        this.score = score;\n    }\n}\n\nclass TrendingPostsTracker {\n    private int k;\n    private Map\u003cString, Integer\u003e postScores; // Stores current score for each post_id\n    private PriorityQueue\u003cPostUpdate\u003e minHeap; // Stores (score, post_id) for the top k posts\n\n    public TrendingPostsTracker(int k) {\n        this.k = k;\n        this.postScores = new HashMap\u003c\u003e();\n        this.minHeap = new PriorityQueue\u003c\u003e(Comparator.comparingInt(pu -\u003e pu.score));\n    }\n\n    public void updatePostScore(PostUpdate postUpdate) {\n        // Your code here\n    }\n\n    public List\u003cString\u003e getTopKPosts() {\n        // Your code here\n        return new ArrayList\u003c\u003e();\n    }\n}",
    "javascript": "class PostUpdate {\n    constructor(postId, score) {\n        this.postId = postId;\n        this.score = score;\n    }\n}\n\nclass TrendingPostsTracker {\n    constructor(k) {\n        this.k = k;\n        this.postScores = new Map(); // postId -\u003e score\n        // You might need a custom min-priority queue implementation or library for JavaScript\n        // For simplicity, consider sorting or using an array for the top K and managing it.\n        this.topKPosts = []; // Stores {postId: string, score: number} objects\n    }\n\n    updatePostScore(postUpdate) {\n        // Your code here (consider managing `this.topKPosts` as an array and re-sorting or using a min-heap structure if available)\n    }\n\n    getTopKPosts() {\n        // Your code here (ensure sorted by score descending)\n        return this.topKPosts.map(p =\u003e p.postId).sort((a, b) =\u003e this.postScores.get(b) - this.postScores.get(a));\n    }\n}",
    "python": "from typing import List, Dict\nimport heapq\n\nclass PostUpdate:\n    def __init__(self, post_id: str, score: int):\n        self.post_id = post_id\n        self.score = score\n\n    # For use with heapq, define comparison based on score\n    def __lt__(self, other): # For min-heap, store (score, post_id)\n        return self.score \u003c other.score\n\nclass TrendingPostsTracker:\n    def __init__(self, k: int):\n        self.k = k\n        self.post_scores = {} # type: Dict[str, int] # Stores current score for each post_id\n        self.min_heap = [] # type: List[tuple[int, str]] # (score, post_id) for the top k posts\n\n    def update_post_score(self, post_update: PostUpdate) -\u003e None:\n        # Your code here\n        pass\n\n    def get_top_k_posts(self) -\u003e List[str]:\n        # Your code here\n        return []",
    "rust": "use std::collections::HashMap;\nuse std::collections::BinaryHeap;\nuse std::cmp::Ordering;\n\n#[derive(Eq, PartialEq, Debug, Clone)]\npub struct PostUpdate {\n    pub post_id: String,\n    pub score: i32,\n}\n\n// Implement Ord for PostUpdate to use with BinaryHeap (max-heap by default in Rust).\n// For a min-heap, we'll store Negative scores or wrap.\nimpl Ord for PostUpdate {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        // For min-heap behavior with BinaryHeap (which is a max-heap), invert the comparison\n        other.score.cmp(\u0026self.score)\n    }\n}\n\nimpl PartialOrd for PostUpdate {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\npub struct TrendingPostsTracker {\n    k: usize,\n    post_scores: HashMap\u003cString, i32\u003e, // Stores current score for each post_id\n    min_heap: BinaryHeap\u003cPostUpdate\u003e, // Stores (score, post_id) for the top k posts. Will act as min-heap by inverting scores or custom Ord.\n}\n\nimpl TrendingPostsTracker {\n    pub fn new(k: usize) -\u003e Self {\n        TrendingPostsTracker {\n            k,\n            post_scores: HashMap::new(),\n            min_heap: BinaryHeap::new(),\n        }\n    }\n\n    pub fn update_post_score(\u0026mut self, post_update: PostUpdate) {\n        // Your code here\n    }\n\n    pub fn get_top_k_posts(\u0026self) -\u003e Vec\u003cString\u003e {\n        // Your code here\n        vec![]\n    }\n}"
  },
  "Type": "coding"
}